<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionLifecycleHandler;
import com.github.copilot.sdk.json.SessionMetadata;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (var client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(AssistantMessageEvent.class, msg -&gt; {
 * 		System.out.println(msg.getData().content());
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public final class CopilotClient implements AutoCloseable {

<span class="fc" id="L62">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>

    /**
     * Timeout, in seconds, used by {@link #close()} when waiting for graceful
     * shutdown via {@link #stop()}.
     */
    public static final int AUTOCLOSEABLE_TIMEOUT_SECONDS = 10;
    private final CopilotClientOptions options;
    private final CliServerManager serverManager;
<span class="fc" id="L71">    private final LifecycleEventManager lifecycleManager = new LifecycleEventManager();</span>
<span class="fc" id="L72">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L74">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L78">    private final Object modelsCacheLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L84">        this(new CopilotClientOptions());</span>
<span class="fc" id="L85">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L95">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // When cliUrl is set, auto-correct useStdio since we're connecting via TCP
<span class="pc bpc" id="L99" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="fc" id="L100">            this.options.setUseStdio(false);</span>
        }

        // Validate mutually exclusive options: cliUrl and cliPath cannot both be set
<span class="pc bpc" id="L104" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">                &amp;&amp; this.options.getCliPath() != null) {</span>
<span class="fc" id="L106">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L110" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L111" title="All 4 branches covered.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L112">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="fc" id="L118">            URI uri = CliServerManager.parseCliUrl(this.options.getCliUrl());</span>
<span class="fc" id="L119">            this.optionsHost = uri.getHost();</span>
<span class="fc" id="L120">            this.optionsPort = uri.getPort();</span>
<span class="fc" id="L121">        } else {</span>
<span class="fc" id="L122">            this.optionsHost = null;</span>
<span class="fc" id="L123">            this.optionsPort = null;</span>
        }

<span class="fc" id="L126">        this.serverManager = new CliServerManager(this.options);</span>
<span class="fc" id="L127">    }</span>

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L136">            synchronized (this) {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L138">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L140">            }</span>
        }
<span class="fc" id="L142">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L146">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L148">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                JsonRpcClient rpc;
<span class="fc" id="L151">                Process process = null;</span>

<span class="pc bpc" id="L153" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L155">                    rpc = serverManager.connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L158">                    CliServerManager.ProcessInfo processInfo = serverManager.startCliServer();</span>
<span class="fc" id="L159">                    process = processInfo.process();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                    rpc = serverManager.connectToServer(process, processInfo.port() != null ? &quot;localhost&quot; : null,</span>
<span class="fc" id="L161">                            processInfo.port());</span>
                }

<span class="fc" id="L164">                Connection connection = new Connection(rpc, process);</span>

                // Register handlers for server-to-client calls
<span class="fc" id="L167">                RpcHandlerDispatcher dispatcher = new RpcHandlerDispatcher(sessions, lifecycleManager::dispatch);</span>
<span class="fc" id="L168">                dispatcher.registerHandlers(rpc);</span>

                // Verify protocol version
<span class="fc" id="L171">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L173">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L174">                return connection;</span>
<span class="fc" id="L175">            } catch (Exception e) {</span>
<span class="fc" id="L176">                throw new CompletionException(e);</span>
            }
        });
    }

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L182">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L183">        var params = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L184">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L185">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (pingResponse.protocolVersion() == null) {</span>
<span class="nc" id="L188">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (pingResponse.protocolVersion() != expectedVersion) {</span>
<span class="nc" id="L194">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L195">                    + &quot;, but server reports version &quot; + pingResponse.protocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L198">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L206">        var closeFutures = new ArrayList&lt;CompletableFuture&lt;Void&gt;&gt;();</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="fc" id="L209">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="fc" id="L211">                    session.close();</span>
<span class="nc" id="L212">                } catch (Exception e) {</span>
<span class="nc" id="L213">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="fc" id="L214">                }</span>
<span class="fc" id="L215">            }));</span>
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">        sessions.clear();</span>

<span class="fc" id="L219">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L220">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L229">        disposed = true;</span>
<span class="fc" id="L230">        sessions.clear();</span>
<span class="fc" id="L231">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L235">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L236">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L239">        modelsCache = null;</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L242">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L245">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L247">                connection.rpc.close();</span>
<span class="nc" id="L248">            } catch (Exception e) {</span>
<span class="nc" id="L249">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L250">            }</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L255">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L257">                } catch (Exception e) {</span>
<span class="nc" id="L258">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L259">                }</span>
            }
<span class="fc" id="L261">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L277">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L278">            var request = SessionRequestBuilder.buildCreateRequest(config);</span>

<span class="fc" id="L280">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L281">                var session = new CopilotSession(response.sessionId(), connection.rpc, response.workspacePath());</span>
<span class="fc" id="L282">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L283">                sessions.put(response.sessionId(), session);</span>
<span class="fc" id="L284">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L296">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L315">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L316">            var request = SessionRequestBuilder.buildResumeRequest(sessionId, config);</span>

<span class="fc" id="L318">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L319">                var session = new CopilotSession(response.sessionId(), connection.rpc, response.workspacePath());</span>
<span class="fc" id="L320">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L321">                sessions.put(response.sessionId(), session);</span>
<span class="fc" id="L322">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L336">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L347">            return ConnectionState.DISCONNECTED;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="fc" id="L349">            return ConnectionState.ERROR;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (!connectionFuture.isDone())</span>
<span class="fc" id="L351">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L352">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L367">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L379">        return ensureConnected()</span>
<span class="fc" id="L380">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L390">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L391">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L405">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L407">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L410">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L412">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L414">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L416">            }</span>

<span class="fc" id="L418">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L419">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L420">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L421">                    modelsCache = models;</span>
<span class="fc" id="L422">                }</span>
<span class="fc" id="L423">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L439">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L440">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L441">                        .thenApply(GetLastSessionIdResponse::sessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L456">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L457">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L458">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">                    if (!response.success()) {</span>
<span class="nc" id="L460">                        throw new RuntimeException(&quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.error());</span>
                    }
<span class="fc" id="L462">                    sessions.remove(sessionId);</span>
<span class="fc" id="L463">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L477">        return ensureConnected()</span>
<span class="fc" id="L478">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L479">                        .thenApply(ListSessionsResponse::sessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L492">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L493">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L495">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::sessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L511">        return ensureConnected()</span>
<span class="nc" id="L512">                .thenCompose(</span>
<span class="nc" id="L513">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L514">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L516">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                                    if (!response.success()) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                                        throw new RuntimeException(response.error() != null</span>
<span class="nc" id="L519">                                                ? response.error()</span>
<span class="nc" id="L520">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L522">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(SessionLifecycleHandler handler) {
<span class="fc" id="L536">        return lifecycleManager.subscribe(handler);</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, SessionLifecycleHandler handler) {
<span class="fc" id="L551">        return lifecycleManager.subscribe(eventType, handler);</span>
    }

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="fc bfc" id="L555" title="All 4 branches covered.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="fc" id="L556">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L559">        start();</span>
<span class="fc" id="L560">        return connectionFuture;</span>
    }

    /**
     * Closes this client using graceful shutdown semantics.
     * &lt;p&gt;
     * This method is intended for {@code try-with-resources} usage and blocks while
     * waiting for {@link #stop()} to complete, up to
     * {@link #AUTOCLOSEABLE_TIMEOUT_SECONDS} seconds. If shutdown fails or times
     * out, the error is logged at {@link Level#FINE} and the method returns.
     * &lt;p&gt;
     * This method is idempotent.
     *
     * @see #stop()
     * @see #forceStop()
     * @see #AUTOCLOSEABLE_TIMEOUT_SECONDS
     */
    @Override
    public void close() {
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (disposed)</span>
<span class="fc" id="L580">            return;</span>
<span class="fc" id="L581">        disposed = true;</span>
        try {
<span class="fc" id="L583">            stop().get(AUTOCLOSEABLE_TIMEOUT_SECONDS, TimeUnit.SECONDS);</span>
<span class="nc" id="L584">        } catch (Exception e) {</span>
<span class="nc" id="L585">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L586">        }</span>
<span class="fc" id="L587">    }</span>

<span class="fc" id="L589">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>