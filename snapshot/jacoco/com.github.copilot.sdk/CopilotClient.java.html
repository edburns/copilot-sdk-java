<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionRequest;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionRequest;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionMetadata;
import com.github.copilot.sdk.json.ToolDef;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.ToolInvocation;
import com.github.copilot.sdk.json.ToolResultObject;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (CopilotClient client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	CopilotSession session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(evt -&gt; {
 * 		if (evt instanceof AssistantMessageEvent msg) {
 * 			System.out.println(msg.getData().getContent());
 * 		}
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public class CopilotClient implements AutoCloseable {

<span class="fc" id="L84">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>
<span class="fc" id="L85">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final CopilotClientOptions options;
<span class="fc" id="L88">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L90">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L94">    private final Object modelsCacheLock = new Object();</span>
<span class="fc" id="L95">    private final List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; lifecycleHandlers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L96">    private final Map&lt;String, List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt;&gt; typedLifecycleHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L97">    private final Object lifecycleHandlersLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L103">        this(new CopilotClientOptions());</span>
<span class="fc" id="L104">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L114">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // Validate mutually exclusive options
<span class="pc bpc" id="L118" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L119" title="All 4 branches covered.">                &amp;&amp; (this.options.isUseStdio() || this.options.getCliPath() != null)) {</span>
<span class="fc" id="L120">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with UseStdio and CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="pc bpc" id="L125" title="1 of 4 branches missed.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L126">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L131" title="3 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="nc" id="L132">            URI uri = parseCliUrl(this.options.getCliUrl());</span>
<span class="nc" id="L133">            this.optionsHost = uri.getHost();</span>
<span class="nc" id="L134">            this.optionsPort = uri.getPort();</span>
<span class="nc" id="L135">        } else {</span>
<span class="fc" id="L136">            this.optionsHost = null;</span>
<span class="fc" id="L137">            this.optionsPort = null;</span>
        }
<span class="fc" id="L139">    }</span>

    private static URI parseCliUrl(String url) {
        // If it's just a port number, treat as localhost
        try {
<span class="nc" id="L144">            int port = Integer.parseInt(url);</span>
<span class="nc" id="L145">            return URI.create(&quot;http://localhost:&quot; + port);</span>
<span class="nc" id="L146">        } catch (NumberFormatException e) {</span>
            // Not a port number, continue
        }

        // Add scheme if missing
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (!url.toLowerCase().startsWith(&quot;http://&quot;) &amp;&amp; !url.toLowerCase().startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L152">            url = &quot;https://&quot; + url;</span>
        }

<span class="nc" id="L155">        return URI.create(url);</span>
    }

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L165">            synchronized (this) {</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L167">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L169">            }</span>
        }
<span class="fc" id="L171">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L175">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L177">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                Connection connection;

<span class="pc bpc" id="L181" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L183">                    connection = connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L186">                    ProcessInfo processInfo = startCliServer();</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">                    connection = connectToServer(processInfo.process, processInfo.port != null ? &quot;localhost&quot; : null,</span>
                            processInfo.port);
                }

                // Register handlers for server-to-client calls
<span class="fc" id="L192">                registerRpcHandlers(connection.rpc);</span>

                // Verify protocol version
<span class="fc" id="L195">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L197">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L198">                return connection;</span>
<span class="nc" id="L199">            } catch (Exception e) {</span>
<span class="nc" id="L200">                throw new CompletionException(e);</span>
            }
        });
    }

    private void registerRpcHandlers(JsonRpcClient rpc) {
        // Handle session events
<span class="fc" id="L207">        rpc.registerMethodHandler(&quot;session.event&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="fc" id="L209">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L210">                JsonNode eventNode = params.get(&quot;event&quot;);</span>
<span class="fc" id="L211">                LOG.fine(&quot;Received session.event: &quot; + eventNode);</span>

<span class="fc" id="L213">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">                if (session != null &amp;&amp; eventNode != null) {</span>
<span class="fc" id="L215">                    AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                    if (event != null) {</span>
<span class="fc" id="L217">                        session.dispatchEvent(event);</span>
                    }
                }
<span class="nc" id="L220">            } catch (Exception e) {</span>
<span class="nc" id="L221">                LOG.log(Level.SEVERE, &quot;Error handling session event&quot;, e);</span>
<span class="fc" id="L222">            }</span>
<span class="fc" id="L223">        });</span>

        // Handle session lifecycle events
<span class="fc" id="L226">        rpc.registerMethodHandler(&quot;session.lifecycle&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                String type = params.has(&quot;type&quot;) ? params.get(&quot;type&quot;).asText() : &quot;&quot;;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                String sessionId = params.has(&quot;sessionId&quot;) ? params.get(&quot;sessionId&quot;).asText() : &quot;&quot;;</span>

<span class="fc" id="L231">                com.github.copilot.sdk.json.SessionLifecycleEvent event = new com.github.copilot.sdk.json.SessionLifecycleEvent();</span>
<span class="fc" id="L232">                event.setType(type);</span>
<span class="fc" id="L233">                event.setSessionId(sessionId);</span>

<span class="pc bpc" id="L235" title="1 of 4 branches missed.">                if (params.has(&quot;metadata&quot;) &amp;&amp; !params.get(&quot;metadata&quot;).isNull()) {</span>
<span class="fc" id="L236">                    com.github.copilot.sdk.json.SessionLifecycleEventMetadata metadata = MAPPER.treeToValue(</span>
<span class="fc" id="L237">                            params.get(&quot;metadata&quot;), com.github.copilot.sdk.json.SessionLifecycleEventMetadata.class);</span>
<span class="fc" id="L238">                    event.setMetadata(metadata);</span>
                }

<span class="fc" id="L241">                dispatchLifecycleEvent(event);</span>
<span class="nc" id="L242">            } catch (Exception e) {</span>
<span class="nc" id="L243">                LOG.log(Level.SEVERE, &quot;Error handling session lifecycle event&quot;, e);</span>
<span class="fc" id="L244">            }</span>
<span class="fc" id="L245">        });</span>

        // Handle tool calls
<span class="fc" id="L248">        rpc.registerMethodHandler(&quot;tool.call&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L249">            handleToolCall(rpc, requestId, params);</span>
<span class="fc" id="L250">        });</span>

        // Handle permission requests
<span class="fc" id="L253">        rpc.registerMethodHandler(&quot;permission.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L254">            handlePermissionRequest(rpc, requestId, params);</span>
<span class="fc" id="L255">        });</span>

        // Handle user input requests
<span class="fc" id="L258">        rpc.registerMethodHandler(&quot;userInput.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L259">            handleUserInputRequest(rpc, requestId, params);</span>
<span class="fc" id="L260">        });</span>

        // Handle hooks invocations
<span class="fc" id="L263">        rpc.registerMethodHandler(&quot;hooks.invoke&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L264">            handleHooksInvoke(rpc, requestId, params);</span>
<span class="fc" id="L265">        });</span>
<span class="fc" id="L266">    }</span>

    private void handleToolCall(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L269">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L271">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L272">                String toolCallId = params.get(&quot;toolCallId&quot;).asText();</span>
<span class="fc" id="L273">                String toolName = params.get(&quot;toolName&quot;).asText();</span>
<span class="fc" id="L274">                JsonNode arguments = params.get(&quot;arguments&quot;);</span>

<span class="fc" id="L276">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L278">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L279">                    return;</span>
                }

<span class="fc" id="L282">                ToolDefinition tool = session.getTool(toolName);</span>
<span class="pc bpc" id="L283" title="2 of 4 branches missed.">                if (tool == null || tool.getHandler() == null) {</span>
<span class="nc" id="L284">                    ToolResultObject result = new ToolResultObject()</span>
<span class="nc" id="L285">                            .setTextResultForLlm(&quot;Tool '&quot; + toolName + &quot;' is not supported.&quot;).setResultType(&quot;failure&quot;)</span>
<span class="nc" id="L286">                            .setError(&quot;tool '&quot; + toolName + &quot;' not supported&quot;);</span>
<span class="nc" id="L287">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L288">                    return;</span>
                }

<span class="fc" id="L291">                ToolInvocation invocation = new ToolInvocation().setSessionId(sessionId).setToolCallId(toolCallId)</span>
<span class="fc" id="L292">                        .setToolName(toolName).setArguments(arguments);</span>

<span class="fc" id="L294">                tool.getHandler().invoke(invocation).thenAccept(result -&gt; {</span>
                    try {
                        ToolResultObject toolResult;
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">                        if (result instanceof ToolResultObject tr) {</span>
<span class="nc" id="L298">                            toolResult = tr;</span>
                        } else {
<span class="fc" id="L300">                            toolResult = new ToolResultObject().setResultType(&quot;success&quot;).setTextResultForLlm(</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                                    result instanceof String s ? s : MAPPER.writeValueAsString(result));</span>
                        }
<span class="fc" id="L303">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, toolResult));</span>
<span class="nc" id="L304">                    } catch (Exception e) {</span>
<span class="nc" id="L305">                        LOG.log(Level.SEVERE, &quot;Error sending tool result&quot;, e);</span>
<span class="fc" id="L306">                    }</span>
<span class="fc" id="L307">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L309">                        ToolResultObject result = new ToolResultObject()</span>
<span class="fc" id="L310">                                .setTextResultForLlm(</span>
                                        &quot;Invoking this tool produced an error. Detailed information is not available.&quot;)
<span class="fc" id="L312">                                .setResultType(&quot;failure&quot;).setError(ex.getMessage());</span>
<span class="fc" id="L313">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L314">                    } catch (Exception e) {</span>
<span class="nc" id="L315">                        LOG.log(Level.SEVERE, &quot;Error sending tool error&quot;, e);</span>
<span class="fc" id="L316">                    }</span>
<span class="fc" id="L317">                    return null;</span>
                });
<span class="nc" id="L319">            } catch (Exception e) {</span>
<span class="nc" id="L320">                LOG.log(Level.SEVERE, &quot;Error handling tool call&quot;, e);</span>
                try {
<span class="nc" id="L322">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32603, e.getMessage());</span>
<span class="nc" id="L323">                } catch (IOException ioe) {</span>
<span class="nc" id="L324">                    LOG.log(Level.SEVERE, &quot;Failed to send error response&quot;, ioe);</span>
<span class="nc" id="L325">                }</span>
<span class="fc" id="L326">            }</span>
<span class="fc" id="L327">        });</span>
<span class="fc" id="L328">    }</span>

    private void handlePermissionRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L331">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L333">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L334">                JsonNode permissionRequest = params.get(&quot;permissionRequest&quot;);</span>

<span class="fc" id="L336">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L338">                    PermissionRequestResult result = new PermissionRequestResult()</span>
<span class="nc" id="L339">                            .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L340">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L341">                    return;</span>
                }

<span class="fc" id="L344">                session.handlePermissionRequest(permissionRequest).thenAccept(result -&gt; {</span>
                    try {
<span class="fc" id="L346">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L347">                    } catch (IOException e) {</span>
<span class="nc" id="L348">                        LOG.log(Level.SEVERE, &quot;Error sending permission result&quot;, e);</span>
<span class="fc" id="L349">                    }</span>
<span class="fc" id="L350">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="nc" id="L352">                        PermissionRequestResult result = new PermissionRequestResult()</span>
<span class="nc" id="L353">                                .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L354">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L355">                    } catch (IOException e) {</span>
<span class="nc" id="L356">                        LOG.log(Level.SEVERE, &quot;Error sending permission denied&quot;, e);</span>
<span class="nc" id="L357">                    }</span>
<span class="nc" id="L358">                    return null;</span>
                });
<span class="nc" id="L360">            } catch (Exception e) {</span>
<span class="nc" id="L361">                LOG.log(Level.SEVERE, &quot;Error handling permission request&quot;, e);</span>
<span class="fc" id="L362">            }</span>
<span class="fc" id="L363">        });</span>
<span class="fc" id="L364">    }</span>

    private void handleUserInputRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L367">        LOG.fine(&quot;Received userInput.request: &quot; + params);</span>
<span class="fc" id="L368">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L370">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L371">                String question = params.get(&quot;question&quot;).asText();</span>
<span class="fc" id="L372">                LOG.fine(&quot;Processing userInput for session &quot; + sessionId + &quot;, question: &quot; + question);</span>
<span class="fc" id="L373">                JsonNode choicesNode = params.get(&quot;choices&quot;);</span>
<span class="fc" id="L374">                JsonNode allowFreeformNode = params.get(&quot;allowFreeform&quot;);</span>

<span class="fc" id="L376">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                LOG.fine(&quot;Found session: &quot; + (session != null));</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L379">                    LOG.fine(&quot;Session not found, sending error&quot;);</span>
<span class="nc" id="L380">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L381">                    return;</span>
                }

<span class="fc" id="L384">                com.github.copilot.sdk.json.UserInputRequest request = new com.github.copilot.sdk.json.UserInputRequest()</span>
<span class="fc" id="L385">                        .setQuestion(question);</span>
<span class="pc bpc" id="L386" title="1 of 4 branches missed.">                if (choicesNode != null &amp;&amp; choicesNode.isArray()) {</span>
<span class="fc" id="L387">                    List&lt;String&gt; choices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                    for (JsonNode choice : choicesNode) {</span>
<span class="fc" id="L389">                        choices.add(choice.asText());</span>
<span class="fc" id="L390">                    }</span>
<span class="fc" id="L391">                    request.setChoices(choices);</span>
                }
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                if (allowFreeformNode != null) {</span>
<span class="fc" id="L394">                    request.setAllowFreeform(allowFreeformNode.asBoolean());</span>
                }

<span class="fc" id="L397">                session.handleUserInputRequest(request).thenAccept(response -&gt; {</span>
                    try {
                        // Ensure answer is never null - CLI requires a non-null string
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                        String answer = response.getAnswer() != null ? response.getAnswer() : &quot;&quot;;</span>
<span class="fc" id="L401">                        LOG.fine(&quot;Sending userInput response: answer=&quot; + answer + &quot;, wasFreeform=&quot;</span>
<span class="fc" id="L402">                                + response.isWasFreeform());</span>
<span class="fc" id="L403">                        rpc.sendResponse(Long.parseLong(requestId),</span>
<span class="fc" id="L404">                                Map.of(&quot;answer&quot;, answer, &quot;wasFreeform&quot;, response.isWasFreeform()));</span>
<span class="nc" id="L405">                    } catch (IOException e) {</span>
<span class="nc" id="L406">                        LOG.log(Level.SEVERE, &quot;Error sending user input response&quot;, e);</span>
<span class="fc" id="L407">                    }</span>
<span class="fc" id="L408">                }).exceptionally(ex -&gt; {</span>
<span class="nc" id="L409">                    LOG.log(Level.WARNING, &quot;User input handler exception&quot;, ex);</span>
                    try {
<span class="nc" id="L411">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="nc" id="L412">                                &quot;User input handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L413">                    } catch (IOException e) {</span>
<span class="nc" id="L414">                        LOG.log(Level.SEVERE, &quot;Error sending user input error&quot;, e);</span>
<span class="nc" id="L415">                    }</span>
<span class="nc" id="L416">                    return null;</span>
                });
<span class="nc" id="L418">            } catch (Exception e) {</span>
<span class="nc" id="L419">                LOG.log(Level.SEVERE, &quot;Error handling user input request&quot;, e);</span>
<span class="fc" id="L420">            }</span>
<span class="fc" id="L421">        });</span>
<span class="fc" id="L422">    }</span>

    private void handleHooksInvoke(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L425">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L427">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L428">                String hookType = params.get(&quot;hookType&quot;).asText();</span>
<span class="fc" id="L429">                JsonNode input = params.get(&quot;input&quot;);</span>

<span class="fc" id="L431">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L433">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L434">                    return;</span>
                }

<span class="fc" id="L437">                session.handleHooksInvoke(hookType, input).thenAccept(output -&gt; {</span>
                    try {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">                        if (output != null) {</span>
<span class="fc" id="L440">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, output));</span>
                        } else {
<span class="nc" id="L442">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, (Object) null));</span>
                        }
<span class="nc" id="L444">                    } catch (IOException e) {</span>
<span class="nc" id="L445">                        LOG.log(Level.SEVERE, &quot;Error sending hooks response&quot;, e);</span>
<span class="fc" id="L446">                    }</span>
<span class="fc" id="L447">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L449">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="fc" id="L450">                                &quot;Hooks handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L451">                    } catch (IOException e) {</span>
<span class="nc" id="L452">                        LOG.log(Level.SEVERE, &quot;Error sending hooks error&quot;, e);</span>
<span class="fc" id="L453">                    }</span>
<span class="fc" id="L454">                    return null;</span>
                });
<span class="nc" id="L456">            } catch (Exception e) {</span>
<span class="nc" id="L457">                LOG.log(Level.SEVERE, &quot;Error handling hooks invoke&quot;, e);</span>
<span class="fc" id="L458">            }</span>
<span class="fc" id="L459">        });</span>
<span class="fc" id="L460">    }</span>

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L463">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L464">        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc" id="L465">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L466">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() == null) {</span>
<span class="nc" id="L469">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() != expectedVersion) {</span>
<span class="nc" id="L475">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L476">                    + &quot;, but server reports version &quot; + pingResponse.getProtocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L479">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L487">        List&lt;CompletableFuture&lt;Void&gt;&gt; closeFutures = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="nc" id="L490">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="nc" id="L492">                    session.close();</span>
<span class="nc" id="L493">                } catch (Exception e) {</span>
<span class="nc" id="L494">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="nc" id="L495">                }</span>
<span class="nc" id="L496">            }));</span>
<span class="nc" id="L497">        }</span>
<span class="fc" id="L498">        sessions.clear();</span>

<span class="fc" id="L500">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L501">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L510">        sessions.clear();</span>
<span class="fc" id="L511">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L515">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L516">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L519">        modelsCache = null;</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L522">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L525">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L527">                connection.rpc.close();</span>
<span class="nc" id="L528">            } catch (Exception e) {</span>
<span class="nc" id="L529">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L530">            }</span>

<span class="pc bpc" id="L532" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L535">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L537">                } catch (Exception e) {</span>
<span class="nc" id="L538">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L539">                }</span>
            }
<span class="pc" id="L541">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L557">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L558">            CreateSessionRequest request = new CreateSessionRequest();</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L560">                request.setModel(config.getModel());</span>
<span class="fc" id="L561">                request.setSessionId(config.getSessionId());</span>
<span class="fc" id="L562">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                request.setTools(config.getTools() != null</span>
<span class="fc" id="L564">                        ? config.getTools().stream()</span>
<span class="fc" id="L565">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="fc" id="L566">                                .collect(Collectors.toList())</span>
<span class="fc" id="L567">                        : null);</span>
<span class="fc" id="L568">                request.setSystemMessage(config.getSystemMessage());</span>
<span class="fc" id="L569">                request.setAvailableTools(config.getAvailableTools());</span>
<span class="fc" id="L570">                request.setExcludedTools(config.getExcludedTools());</span>
<span class="fc" id="L571">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">                boolean requestUserInput = config.getOnUserInputRequest() != null;</span>
<span class="fc" id="L574">                LOG.fine(&quot;Setting requestUserInput: &quot; + requestUserInput + &quot; for session.create&quot;);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                request.setRequestUserInput(requestUserInput ? true : null);</span>
<span class="pc bpc" id="L576" title="1 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L577">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L579">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L580">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L581">                request.setInfiniteSessions(config.getInfiniteSessions());</span>
<span class="fc" id="L582">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L583">                request.setDisabledSkills(config.getDisabledSkills());</span>
<span class="fc" id="L584">                request.setConfigDir(config.getConfigDir());</span>
            }

<span class="fc" id="L587">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L588">                CopilotSession session = new CopilotSession(response.getSessionId(), connection.rpc,</span>
<span class="fc" id="L589">                        response.getWorkspacePath());</span>
<span class="fc bfc" id="L590" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="fc" id="L591">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L593" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L594">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="fc bfc" id="L596" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="fc" id="L597">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="fc bfc" id="L599" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="fc" id="L600">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L602">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L603">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L615">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L634">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L635">            ResumeSessionRequest request = new ResumeSessionRequest();</span>
<span class="fc" id="L636">            request.setSessionId(sessionId);</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L638">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">                request.setTools(config.getTools() != null</span>
<span class="nc" id="L640">                        ? config.getTools().stream()</span>
<span class="nc" id="L641">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="nc" id="L642">                                .collect(Collectors.toList())</span>
<span class="fc" id="L643">                        : null);</span>
<span class="fc" id="L644">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">                request.setRequestUserInput(config.getOnUserInputRequest() != null ? true : null);</span>
<span class="pc bpc" id="L647" title="3 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L648">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                request.setDisableResume(config.isDisableResume() ? true : null);</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L651">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L652">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L653">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L654">                request.setDisabledSkills(config.getDisabledSkills());</span>
            }

<span class="fc" id="L657">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L658">                CopilotSession session = new CopilotSession(response.getSessionId(), connection.rpc,</span>
<span class="fc" id="L659">                        response.getWorkspacePath());</span>
<span class="pc bpc" id="L660" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="nc" id="L661">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L663" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L664">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="pc bpc" id="L666" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="nc" id="L667">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="pc bpc" id="L669" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="nc" id="L670">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L672">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L673">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L687">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L698">            return ConnectionState.DISCONNECTED;</span>
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="nc" id="L700">            return ConnectionState.ERROR;</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">        if (!connectionFuture.isDone())</span>
<span class="nc" id="L702">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L703">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L718">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L730">        return ensureConnected()</span>
<span class="fc" id="L731">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L741">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L742">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L756">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L758">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L761">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L763">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L765">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L767">            }</span>

<span class="fc" id="L769">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L770">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L771">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L772">                    modelsCache = models;</span>
<span class="fc" id="L773">                }</span>
<span class="fc" id="L774">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L790">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L791">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L792">                        .thenApply(GetLastSessionIdResponse::getSessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L807">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L808">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L809">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                    if (!response.isSuccess()) {</span>
<span class="nc" id="L811">                        throw new RuntimeException(</span>
<span class="nc" id="L812">                                &quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.getError());</span>
                    }
<span class="fc" id="L814">                    sessions.remove(sessionId);</span>
<span class="fc" id="L815">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L829">        return ensureConnected()</span>
<span class="fc" id="L830">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L831">                        .thenApply(ListSessionsResponse::getSessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L844">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L845">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L847">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::getSessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L863">        return ensureConnected()</span>
<span class="nc" id="L864">                .thenCompose(</span>
<span class="nc" id="L865">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L866">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L868">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">                                    if (!response.isSuccess()) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                                        throw new RuntimeException(response.getError() != null</span>
<span class="nc" id="L871">                                                ? response.getError()</span>
<span class="nc" id="L872">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L874">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L888">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L889">            lifecycleHandlers.add(handler);</span>
<span class="nc" id="L890">        }</span>
<span class="nc" id="L891">        return () -&gt; {</span>
<span class="nc" id="L892">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L893">                lifecycleHandlers.remove(handler);</span>
<span class="nc" id="L894">            }</span>
<span class="nc" id="L895">        };</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L910">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L911">            typedLifecycleHandlers.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;()).add(handler);</span>
<span class="nc" id="L912">        }</span>
<span class="nc" id="L913">        return () -&gt; {</span>
<span class="nc" id="L914">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L915">                List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="nc" id="L916">                        .get(eventType);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                if (handlers != null) {</span>
<span class="nc" id="L918">                    handlers.remove(handler);</span>
                }
<span class="nc" id="L920">            }</span>
<span class="nc" id="L921">        };</span>
    }

    void dispatchLifecycleEvent(com.github.copilot.sdk.json.SessionLifecycleEvent event) {
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; typed;
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; wildcard;

<span class="fc" id="L928">        synchronized (lifecycleHandlersLock) {</span>
<span class="fc" id="L929">            List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="fc" id="L930">                    .get(event.getType());</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            typed = handlers != null ? new ArrayList&lt;&gt;(handlers) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L932">            wildcard = new ArrayList&lt;&gt;(lifecycleHandlers);</span>
<span class="fc" id="L933">        }</span>

<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : typed) {</span>
            try {
<span class="nc" id="L937">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L938">            } catch (Exception e) {</span>
<span class="nc" id="L939">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L940">            }</span>
<span class="nc" id="L941">        }</span>

<span class="pc bpc" id="L943" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : wildcard) {</span>
            try {
<span class="nc" id="L945">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L946">            } catch (Exception e) {</span>
<span class="nc" id="L947">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L948">            }</span>
<span class="nc" id="L949">        }</span>
<span class="fc" id="L950">    }</span>

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="pc bpc" id="L953" title="1 of 4 branches missed.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="nc" id="L954">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L957">        start();</span>
<span class="fc" id="L958">        return connectionFuture;</span>
    }

    private ProcessInfo startCliServer() throws IOException, InterruptedException {
<span class="pc bpc" id="L962" title="1 of 2 branches missed.">        String cliPath = options.getCliPath() != null ? options.getCliPath() : &quot;copilot&quot;;</span>
<span class="fc" id="L963">        List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L965" title="1 of 2 branches missed.">        if (options.getCliArgs() != null) {</span>
<span class="nc" id="L966">            args.addAll(Arrays.asList(options.getCliArgs()));</span>
        }

<span class="fc" id="L969">        args.add(&quot;--server&quot;);</span>
<span class="fc" id="L970">        args.add(&quot;--log-level&quot;);</span>
<span class="fc" id="L971">        args.add(options.getLogLevel());</span>

<span class="fc bfc" id="L973" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="fc" id="L974">            args.add(&quot;--stdio&quot;);</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">        } else if (options.getPort() &gt; 0) {</span>
<span class="nc" id="L976">            args.add(&quot;--port&quot;);</span>
<span class="nc" id="L977">            args.add(String.valueOf(options.getPort()));</span>
        }

        // Add auth-related flags
<span class="pc bpc" id="L981" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L982">            args.add(&quot;--auth-token-env&quot;);</span>
<span class="fc" id="L983">            args.add(&quot;COPILOT_SDK_AUTH_TOKEN&quot;);</span>
        }

        // Default UseLoggedInUser to false when GithubToken is provided
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">        boolean useLoggedInUser = options.getUseLoggedInUser() != null</span>
<span class="nc" id="L988">                ? options.getUseLoggedInUser()</span>
<span class="pc bpc" id="L989" title="1 of 4 branches missed.">                : (options.getGithubToken() == null || options.getGithubToken().isEmpty());</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">        if (!useLoggedInUser) {</span>
<span class="fc" id="L991">            args.add(&quot;--no-auto-login&quot;);</span>
        }

<span class="fc" id="L994">        List&lt;String&gt; command = resolveCliCommand(cliPath, args);</span>

<span class="fc" id="L996">        ProcessBuilder pb = new ProcessBuilder(command);</span>
<span class="fc" id="L997">        pb.redirectErrorStream(false);</span>

<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (options.getCwd() != null) {</span>
<span class="fc" id="L1000">            pb.directory(new File(options.getCwd()));</span>
        }

<span class="fc bfc" id="L1003" title="All 2 branches covered.">        if (options.getEnvironment() != null) {</span>
<span class="fc" id="L1004">            pb.environment().clear();</span>
<span class="fc" id="L1005">            pb.environment().putAll(options.getEnvironment());</span>
        }
<span class="fc" id="L1007">        pb.environment().remove(&quot;NODE_DEBUG&quot;);</span>

        // Set auth token in environment if provided
<span class="pc bpc" id="L1010" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L1011">            pb.environment().put(&quot;COPILOT_SDK_AUTH_TOKEN&quot;, options.getGithubToken());</span>
        }

<span class="fc" id="L1014">        Process process = pb.start();</span>

        // Forward stderr to logger in background
<span class="fc" id="L1017">        Thread stderrThread = new Thread(() -&gt; {</span>
<span class="fc" id="L1018">            try (BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1019">                    new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {</span>
                String line;
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">                while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L1022">                    LOG.fine(&quot;[CLI] &quot; + line);</span>
                }
<span class="nc" id="L1024">            } catch (IOException e) {</span>
<span class="nc" id="L1025">                LOG.log(Level.FINE, &quot;Error reading stderr&quot;, e);</span>
<span class="fc" id="L1026">            }</span>
<span class="fc" id="L1027">        }, &quot;cli-stderr-reader&quot;);</span>
<span class="fc" id="L1028">        stderrThread.setDaemon(true);</span>
<span class="fc" id="L1029">        stderrThread.start();</span>

<span class="fc" id="L1031">        Integer detectedPort = null;</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        if (!options.isUseStdio()) {</span>
            // Wait for port announcement
<span class="fc" id="L1034">            BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1035">                    new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));</span>
<span class="fc" id="L1036">            Pattern portPattern = Pattern.compile(&quot;listening on port (\\d+)&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L1037">            long deadline = System.currentTimeMillis() + 30000;</span>

<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">            while (System.currentTimeMillis() &lt; deadline) {</span>
<span class="fc" id="L1040">                String line = reader.readLine();</span>
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">                if (line == null) {</span>
<span class="nc" id="L1042">                    throw new IOException(&quot;CLI process exited unexpectedly&quot;);</span>
                }

<span class="fc" id="L1045">                Matcher matcher = portPattern.matcher(line);</span>
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">                if (matcher.find()) {</span>
<span class="fc" id="L1047">                    detectedPort = Integer.parseInt(matcher.group(1));</span>
<span class="fc" id="L1048">                    break;</span>
                }
<span class="nc" id="L1050">            }</span>

<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">            if (detectedPort == null) {</span>
<span class="nc" id="L1053">                process.destroyForcibly();</span>
<span class="nc" id="L1054">                throw new IOException(&quot;Timeout waiting for CLI to announce port&quot;);</span>
            }
        }

<span class="fc" id="L1058">        return new ProcessInfo(process, detectedPort);</span>
    }

    private List&lt;String&gt; resolveCliCommand(String cliPath, List&lt;String&gt; args) {
<span class="fc" id="L1062">        boolean isJsFile = cliPath.toLowerCase().endsWith(&quot;.js&quot;);</span>

<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">        if (isJsFile) {</span>
<span class="fc" id="L1065">            List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1066">            result.add(&quot;node&quot;);</span>
<span class="fc" id="L1067">            result.add(cliPath);</span>
<span class="fc" id="L1068">            result.addAll(args);</span>
<span class="fc" id="L1069">            return result;</span>
        }

        // On Windows, use cmd /c to resolve the executable
<span class="nc" id="L1073">        String os = System.getProperty(&quot;os.name&quot;).toLowerCase();</span>
<span class="nc bnc" id="L1074" title="All 4 branches missed.">        if (os.contains(&quot;win&quot;) &amp;&amp; !new File(cliPath).isAbsolute()) {</span>
<span class="nc" id="L1075">            List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1076">            result.add(&quot;cmd&quot;);</span>
<span class="nc" id="L1077">            result.add(&quot;/c&quot;);</span>
<span class="nc" id="L1078">            result.add(cliPath);</span>
<span class="nc" id="L1079">            result.addAll(args);</span>
<span class="nc" id="L1080">            return result;</span>
        }

<span class="nc" id="L1083">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1084">        result.add(cliPath);</span>
<span class="nc" id="L1085">        result.addAll(args);</span>
<span class="nc" id="L1086">        return result;</span>
    }

    private Connection connectToServer(Process process, String tcpHost, Integer tcpPort) throws IOException {
        JsonRpcClient rpc;

<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">            if (process == null) {</span>
<span class="nc" id="L1094">                throw new IllegalStateException(&quot;CLI process not started&quot;);</span>
            }
<span class="fc" id="L1096">            rpc = JsonRpcClient.fromProcess(process);</span>
        } else {
<span class="pc bpc" id="L1098" title="2 of 4 branches missed.">            if (tcpHost == null || tcpPort == null) {</span>
<span class="nc" id="L1099">                throw new IllegalStateException(&quot;Cannot connect because TCP host or port are not available&quot;);</span>
            }
<span class="fc" id="L1101">            Socket socket = new Socket(tcpHost, tcpPort);</span>
<span class="fc" id="L1102">            rpc = JsonRpcClient.fromSocket(socket);</span>
        }

<span class="fc" id="L1105">        return new Connection(rpc, process);</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">        if (disposed)</span>
<span class="nc" id="L1111">            return;</span>
<span class="fc" id="L1112">        disposed = true;</span>
        try {
<span class="fc" id="L1114">            forceStop().get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L1115">        } catch (Exception e) {</span>
<span class="nc" id="L1116">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L1117">        }</span>
<span class="fc" id="L1118">    }</span>

<span class="fc" id="L1120">    private static record ProcessInfo(Process process, Integer port) {</span>
    };

<span class="fc" id="L1123">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>