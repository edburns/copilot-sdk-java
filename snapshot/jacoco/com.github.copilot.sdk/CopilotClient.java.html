<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionRequest;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionRequest;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionMetadata;
import com.github.copilot.sdk.json.ToolDef;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.ToolInvocation;
import com.github.copilot.sdk.json.ToolResultObject;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (var client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(AssistantMessageEvent.class, msg -&gt; {
 * 		System.out.println(msg.getData().getContent());
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public final class CopilotClient implements AutoCloseable {

<span class="fc" id="L82">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>
<span class="fc" id="L83">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final CopilotClientOptions options;
<span class="fc" id="L86">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L88">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L92">    private final Object modelsCacheLock = new Object();</span>
<span class="fc" id="L93">    private final List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; lifecycleHandlers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L94">    private final Map&lt;String, List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt;&gt; typedLifecycleHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">    private final Object lifecycleHandlersLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L101">        this(new CopilotClientOptions());</span>
<span class="fc" id="L102">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L112">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // Validate mutually exclusive options
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L117" title="All 4 branches covered.">                &amp;&amp; (this.options.isUseStdio() || this.options.getCliPath() != null)) {</span>
<span class="fc" id="L118">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with UseStdio and CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L124">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L129" title="3 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="nc" id="L130">            URI uri = parseCliUrl(this.options.getCliUrl());</span>
<span class="nc" id="L131">            this.optionsHost = uri.getHost();</span>
<span class="nc" id="L132">            this.optionsPort = uri.getPort();</span>
<span class="nc" id="L133">        } else {</span>
<span class="fc" id="L134">            this.optionsHost = null;</span>
<span class="fc" id="L135">            this.optionsPort = null;</span>
        }
<span class="fc" id="L137">    }</span>

    private static URI parseCliUrl(String url) {
        // If it's just a port number, treat as localhost
        try {
<span class="nc" id="L142">            int port = Integer.parseInt(url);</span>
<span class="nc" id="L143">            return URI.create(&quot;http://localhost:&quot; + port);</span>
<span class="nc" id="L144">        } catch (NumberFormatException e) {</span>
            // Not a port number, continue
        }

        // Add scheme if missing
<span class="nc bnc" id="L149" title="All 4 branches missed.">        if (!url.toLowerCase().startsWith(&quot;http://&quot;) &amp;&amp; !url.toLowerCase().startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L150">            url = &quot;https://&quot; + url;</span>
        }

<span class="nc" id="L153">        return URI.create(url);</span>
    }

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L163">            synchronized (this) {</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L165">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L167">            }</span>
        }
<span class="fc" id="L169">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L173">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L175">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                Connection connection;

<span class="pc bpc" id="L179" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L181">                    connection = connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L184">                    ProcessInfo processInfo = startCliServer();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                    connection = connectToServer(processInfo.process, processInfo.port != null ? &quot;localhost&quot; : null,</span>
                            processInfo.port);
                }

                // Register handlers for server-to-client calls
<span class="fc" id="L190">                registerRpcHandlers(connection.rpc);</span>

                // Verify protocol version
<span class="fc" id="L193">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L195">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L196">                return connection;</span>
<span class="nc" id="L197">            } catch (Exception e) {</span>
<span class="nc" id="L198">                throw new CompletionException(e);</span>
            }
        });
    }

    private void registerRpcHandlers(JsonRpcClient rpc) {
        // Handle session events
<span class="fc" id="L205">        rpc.registerMethodHandler(&quot;session.event&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="fc" id="L207">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L208">                JsonNode eventNode = params.get(&quot;event&quot;);</span>
<span class="fc" id="L209">                LOG.fine(&quot;Received session.event: &quot; + eventNode);</span>

<span class="fc" id="L211">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L212" title="1 of 4 branches missed.">                if (session != null &amp;&amp; eventNode != null) {</span>
<span class="fc" id="L213">                    AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                    if (event != null) {</span>
<span class="fc" id="L215">                        session.dispatchEvent(event);</span>
                    }
                }
<span class="nc" id="L218">            } catch (Exception e) {</span>
<span class="nc" id="L219">                LOG.log(Level.SEVERE, &quot;Error handling session event&quot;, e);</span>
<span class="fc" id="L220">            }</span>
<span class="fc" id="L221">        });</span>

        // Handle session lifecycle events
<span class="fc" id="L224">        rpc.registerMethodHandler(&quot;session.lifecycle&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                String type = params.has(&quot;type&quot;) ? params.get(&quot;type&quot;).asText() : &quot;&quot;;</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                String sessionId = params.has(&quot;sessionId&quot;) ? params.get(&quot;sessionId&quot;).asText() : &quot;&quot;;</span>

<span class="fc" id="L229">                com.github.copilot.sdk.json.SessionLifecycleEvent event = new com.github.copilot.sdk.json.SessionLifecycleEvent();</span>
<span class="fc" id="L230">                event.setType(type);</span>
<span class="fc" id="L231">                event.setSessionId(sessionId);</span>

<span class="pc bpc" id="L233" title="1 of 4 branches missed.">                if (params.has(&quot;metadata&quot;) &amp;&amp; !params.get(&quot;metadata&quot;).isNull()) {</span>
<span class="fc" id="L234">                    com.github.copilot.sdk.json.SessionLifecycleEventMetadata metadata = MAPPER.treeToValue(</span>
<span class="fc" id="L235">                            params.get(&quot;metadata&quot;), com.github.copilot.sdk.json.SessionLifecycleEventMetadata.class);</span>
<span class="fc" id="L236">                    event.setMetadata(metadata);</span>
                }

<span class="fc" id="L239">                dispatchLifecycleEvent(event);</span>
<span class="nc" id="L240">            } catch (Exception e) {</span>
<span class="nc" id="L241">                LOG.log(Level.SEVERE, &quot;Error handling session lifecycle event&quot;, e);</span>
<span class="fc" id="L242">            }</span>
<span class="fc" id="L243">        });</span>

        // Handle tool calls
<span class="fc" id="L246">        rpc.registerMethodHandler(&quot;tool.call&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L247">            handleToolCall(rpc, requestId, params);</span>
<span class="fc" id="L248">        });</span>

        // Handle permission requests
<span class="fc" id="L251">        rpc.registerMethodHandler(&quot;permission.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L252">            handlePermissionRequest(rpc, requestId, params);</span>
<span class="fc" id="L253">        });</span>

        // Handle user input requests
<span class="fc" id="L256">        rpc.registerMethodHandler(&quot;userInput.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L257">            handleUserInputRequest(rpc, requestId, params);</span>
<span class="fc" id="L258">        });</span>

        // Handle hooks invocations
<span class="fc" id="L261">        rpc.registerMethodHandler(&quot;hooks.invoke&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L262">            handleHooksInvoke(rpc, requestId, params);</span>
<span class="fc" id="L263">        });</span>
<span class="fc" id="L264">    }</span>

    private void handleToolCall(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L267">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L269">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L270">                String toolCallId = params.get(&quot;toolCallId&quot;).asText();</span>
<span class="fc" id="L271">                String toolName = params.get(&quot;toolName&quot;).asText();</span>
<span class="fc" id="L272">                JsonNode arguments = params.get(&quot;arguments&quot;);</span>

<span class="fc" id="L274">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L276">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L277">                    return;</span>
                }

<span class="fc" id="L280">                ToolDefinition tool = session.getTool(toolName);</span>
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">                if (tool == null || tool.getHandler() == null) {</span>
<span class="nc" id="L282">                    var result = new ToolResultObject().setTextResultForLlm(&quot;Tool '&quot; + toolName + &quot;' is not supported.&quot;)</span>
<span class="nc" id="L283">                            .setResultType(&quot;failure&quot;).setError(&quot;tool '&quot; + toolName + &quot;' not supported&quot;);</span>
<span class="nc" id="L284">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L285">                    return;</span>
                }

<span class="fc" id="L288">                var invocation = new ToolInvocation().setSessionId(sessionId).setToolCallId(toolCallId)</span>
<span class="fc" id="L289">                        .setToolName(toolName).setArguments(arguments);</span>

<span class="fc" id="L291">                tool.getHandler().invoke(invocation).thenAccept(result -&gt; {</span>
                    try {
                        ToolResultObject toolResult;
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                        if (result instanceof ToolResultObject tr) {</span>
<span class="nc" id="L295">                            toolResult = tr;</span>
                        } else {
<span class="fc" id="L297">                            toolResult = new ToolResultObject().setResultType(&quot;success&quot;).setTextResultForLlm(</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                                    result instanceof String s ? s : MAPPER.writeValueAsString(result));</span>
                        }
<span class="fc" id="L300">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, toolResult));</span>
<span class="nc" id="L301">                    } catch (Exception e) {</span>
<span class="nc" id="L302">                        LOG.log(Level.SEVERE, &quot;Error sending tool result&quot;, e);</span>
<span class="fc" id="L303">                    }</span>
<span class="fc" id="L304">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L306">                        var result = new ToolResultObject()</span>
<span class="fc" id="L307">                                .setTextResultForLlm(</span>
                                        &quot;Invoking this tool produced an error. Detailed information is not available.&quot;)
<span class="fc" id="L309">                                .setResultType(&quot;failure&quot;).setError(ex.getMessage());</span>
<span class="fc" id="L310">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L311">                    } catch (Exception e) {</span>
<span class="nc" id="L312">                        LOG.log(Level.SEVERE, &quot;Error sending tool error&quot;, e);</span>
<span class="fc" id="L313">                    }</span>
<span class="fc" id="L314">                    return null;</span>
                });
<span class="nc" id="L316">            } catch (Exception e) {</span>
<span class="nc" id="L317">                LOG.log(Level.SEVERE, &quot;Error handling tool call&quot;, e);</span>
                try {
<span class="nc" id="L319">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32603, e.getMessage());</span>
<span class="nc" id="L320">                } catch (IOException ioe) {</span>
<span class="nc" id="L321">                    LOG.log(Level.SEVERE, &quot;Failed to send error response&quot;, ioe);</span>
<span class="nc" id="L322">                }</span>
<span class="fc" id="L323">            }</span>
<span class="fc" id="L324">        });</span>
<span class="fc" id="L325">    }</span>

    private void handlePermissionRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L328">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L330">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L331">                JsonNode permissionRequest = params.get(&quot;permissionRequest&quot;);</span>

<span class="fc" id="L333">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L335">                    var result = new PermissionRequestResult()</span>
<span class="nc" id="L336">                            .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L337">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L338">                    return;</span>
                }

<span class="fc" id="L341">                session.handlePermissionRequest(permissionRequest).thenAccept(result -&gt; {</span>
                    try {
<span class="fc" id="L343">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L344">                    } catch (IOException e) {</span>
<span class="nc" id="L345">                        LOG.log(Level.SEVERE, &quot;Error sending permission result&quot;, e);</span>
<span class="fc" id="L346">                    }</span>
<span class="fc" id="L347">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="nc" id="L349">                        var result = new PermissionRequestResult()</span>
<span class="nc" id="L350">                                .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L351">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L352">                    } catch (IOException e) {</span>
<span class="nc" id="L353">                        LOG.log(Level.SEVERE, &quot;Error sending permission denied&quot;, e);</span>
<span class="nc" id="L354">                    }</span>
<span class="nc" id="L355">                    return null;</span>
                });
<span class="nc" id="L357">            } catch (Exception e) {</span>
<span class="nc" id="L358">                LOG.log(Level.SEVERE, &quot;Error handling permission request&quot;, e);</span>
<span class="fc" id="L359">            }</span>
<span class="fc" id="L360">        });</span>
<span class="fc" id="L361">    }</span>

    private void handleUserInputRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L364">        LOG.fine(&quot;Received userInput.request: &quot; + params);</span>
<span class="fc" id="L365">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L367">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L368">                String question = params.get(&quot;question&quot;).asText();</span>
<span class="fc" id="L369">                LOG.fine(&quot;Processing userInput for session &quot; + sessionId + &quot;, question: &quot; + question);</span>
<span class="fc" id="L370">                JsonNode choicesNode = params.get(&quot;choices&quot;);</span>
<span class="fc" id="L371">                JsonNode allowFreeformNode = params.get(&quot;allowFreeform&quot;);</span>

<span class="fc" id="L373">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                LOG.fine(&quot;Found session: &quot; + (session != null));</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L376">                    LOG.fine(&quot;Session not found, sending error&quot;);</span>
<span class="nc" id="L377">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L378">                    return;</span>
                }

<span class="fc" id="L381">                var request = new com.github.copilot.sdk.json.UserInputRequest().setQuestion(question);</span>
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">                if (choicesNode != null &amp;&amp; choicesNode.isArray()) {</span>
<span class="fc" id="L383">                    var choices = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">                    for (JsonNode choice : choicesNode) {</span>
<span class="fc" id="L385">                        choices.add(choice.asText());</span>
<span class="fc" id="L386">                    }</span>
<span class="fc" id="L387">                    request.setChoices(choices);</span>
                }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                if (allowFreeformNode != null) {</span>
<span class="fc" id="L390">                    request.setAllowFreeform(allowFreeformNode.asBoolean());</span>
                }

<span class="fc" id="L393">                session.handleUserInputRequest(request).thenAccept(response -&gt; {</span>
                    try {
                        // Ensure answer is never null - CLI requires a non-null string
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                        String answer = response.getAnswer() != null ? response.getAnswer() : &quot;&quot;;</span>
<span class="fc" id="L397">                        LOG.fine(&quot;Sending userInput response: answer=&quot; + answer + &quot;, wasFreeform=&quot;</span>
<span class="fc" id="L398">                                + response.isWasFreeform());</span>
<span class="fc" id="L399">                        rpc.sendResponse(Long.parseLong(requestId),</span>
<span class="fc" id="L400">                                Map.of(&quot;answer&quot;, answer, &quot;wasFreeform&quot;, response.isWasFreeform()));</span>
<span class="nc" id="L401">                    } catch (IOException e) {</span>
<span class="nc" id="L402">                        LOG.log(Level.SEVERE, &quot;Error sending user input response&quot;, e);</span>
<span class="fc" id="L403">                    }</span>
<span class="fc" id="L404">                }).exceptionally(ex -&gt; {</span>
<span class="nc" id="L405">                    LOG.log(Level.WARNING, &quot;User input handler exception&quot;, ex);</span>
                    try {
<span class="nc" id="L407">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="nc" id="L408">                                &quot;User input handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L409">                    } catch (IOException e) {</span>
<span class="nc" id="L410">                        LOG.log(Level.SEVERE, &quot;Error sending user input error&quot;, e);</span>
<span class="nc" id="L411">                    }</span>
<span class="nc" id="L412">                    return null;</span>
                });
<span class="nc" id="L414">            } catch (Exception e) {</span>
<span class="nc" id="L415">                LOG.log(Level.SEVERE, &quot;Error handling user input request&quot;, e);</span>
<span class="fc" id="L416">            }</span>
<span class="fc" id="L417">        });</span>
<span class="fc" id="L418">    }</span>

    private void handleHooksInvoke(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L421">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L423">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L424">                String hookType = params.get(&quot;hookType&quot;).asText();</span>
<span class="fc" id="L425">                JsonNode input = params.get(&quot;input&quot;);</span>

<span class="fc" id="L427">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L429">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L430">                    return;</span>
                }

<span class="fc" id="L433">                session.handleHooksInvoke(hookType, input).thenAccept(output -&gt; {</span>
                    try {
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">                        if (output != null) {</span>
<span class="fc" id="L436">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, output));</span>
                        } else {
<span class="nc" id="L438">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, (Object) null));</span>
                        }
<span class="nc" id="L440">                    } catch (IOException e) {</span>
<span class="nc" id="L441">                        LOG.log(Level.SEVERE, &quot;Error sending hooks response&quot;, e);</span>
<span class="fc" id="L442">                    }</span>
<span class="fc" id="L443">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L445">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="fc" id="L446">                                &quot;Hooks handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L447">                    } catch (IOException e) {</span>
<span class="nc" id="L448">                        LOG.log(Level.SEVERE, &quot;Error sending hooks error&quot;, e);</span>
<span class="fc" id="L449">                    }</span>
<span class="fc" id="L450">                    return null;</span>
                });
<span class="nc" id="L452">            } catch (Exception e) {</span>
<span class="nc" id="L453">                LOG.log(Level.SEVERE, &quot;Error handling hooks invoke&quot;, e);</span>
<span class="fc" id="L454">            }</span>
<span class="fc" id="L455">        });</span>
<span class="fc" id="L456">    }</span>

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L459">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L460">        var params = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L461">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L462">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() == null) {</span>
<span class="nc" id="L465">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() != expectedVersion) {</span>
<span class="nc" id="L471">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L472">                    + &quot;, but server reports version &quot; + pingResponse.getProtocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L475">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L483">        var closeFutures = new ArrayList&lt;CompletableFuture&lt;Void&gt;&gt;();</span>

<span class="pc bpc" id="L485" title="1 of 2 branches missed.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="nc" id="L486">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="nc" id="L488">                    session.close();</span>
<span class="nc" id="L489">                } catch (Exception e) {</span>
<span class="nc" id="L490">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="nc" id="L491">                }</span>
<span class="nc" id="L492">            }));</span>
<span class="nc" id="L493">        }</span>
<span class="fc" id="L494">        sessions.clear();</span>

<span class="fc" id="L496">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L497">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L506">        sessions.clear();</span>
<span class="fc" id="L507">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L511">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L512">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L515">        modelsCache = null;</span>

<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L518">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L521">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L523">                connection.rpc.close();</span>
<span class="nc" id="L524">            } catch (Exception e) {</span>
<span class="nc" id="L525">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L526">            }</span>

<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L531">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L533">                } catch (Exception e) {</span>
<span class="nc" id="L534">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L535">                }</span>
            }
<span class="pc" id="L537">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L553">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L554">            var request = new CreateSessionRequest();</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L556">                request.setModel(config.getModel());</span>
<span class="fc" id="L557">                request.setSessionId(config.getSessionId());</span>
<span class="fc" id="L558">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                request.setTools(config.getTools() != null</span>
<span class="fc" id="L560">                        ? config.getTools().stream()</span>
<span class="fc" id="L561">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="fc" id="L562">                                .collect(Collectors.toList())</span>
<span class="fc" id="L563">                        : null);</span>
<span class="fc" id="L564">                request.setSystemMessage(config.getSystemMessage());</span>
<span class="fc" id="L565">                request.setAvailableTools(config.getAvailableTools());</span>
<span class="fc" id="L566">                request.setExcludedTools(config.getExcludedTools());</span>
<span class="fc" id="L567">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">                boolean requestUserInput = config.getOnUserInputRequest() != null;</span>
<span class="fc" id="L570">                LOG.fine(&quot;Setting requestUserInput: &quot; + requestUserInput + &quot; for session.create&quot;);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                request.setRequestUserInput(requestUserInput ? true : null);</span>
<span class="pc bpc" id="L572" title="1 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L573">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L575">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L576">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L577">                request.setInfiniteSessions(config.getInfiniteSessions());</span>
<span class="fc" id="L578">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L579">                request.setDisabledSkills(config.getDisabledSkills());</span>
<span class="fc" id="L580">                request.setConfigDir(config.getConfigDir());</span>
            }

<span class="fc" id="L583">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L584">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="fc bfc" id="L585" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="fc" id="L586">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L588" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L589">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="fc bfc" id="L591" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="fc" id="L592">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="fc bfc" id="L594" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="fc" id="L595">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L597">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L598">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L610">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L629">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L630">            var request = new ResumeSessionRequest();</span>
<span class="fc" id="L631">            request.setSessionId(sessionId);</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L633">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">                request.setTools(config.getTools() != null</span>
<span class="nc" id="L635">                        ? config.getTools().stream()</span>
<span class="nc" id="L636">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="nc" id="L637">                                .collect(Collectors.toList())</span>
<span class="fc" id="L638">                        : null);</span>
<span class="fc" id="L639">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                request.setRequestUserInput(config.getOnUserInputRequest() != null ? true : null);</span>
<span class="pc bpc" id="L642" title="3 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L643">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">                request.setDisableResume(config.isDisableResume() ? true : null);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L646">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L647">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L648">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L649">                request.setDisabledSkills(config.getDisabledSkills());</span>
            }

<span class="fc" id="L652">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L653">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="pc bpc" id="L654" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="nc" id="L655">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L657" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L658">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="pc bpc" id="L660" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="nc" id="L661">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="pc bpc" id="L663" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="nc" id="L664">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L666">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L667">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L681">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L692">            return ConnectionState.DISCONNECTED;</span>
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="nc" id="L694">            return ConnectionState.ERROR;</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (!connectionFuture.isDone())</span>
<span class="nc" id="L696">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L697">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L712">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L724">        return ensureConnected()</span>
<span class="fc" id="L725">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L735">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L736">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L750">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L752">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L755">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L757">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L759">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L761">            }</span>

<span class="fc" id="L763">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L764">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L765">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L766">                    modelsCache = models;</span>
<span class="fc" id="L767">                }</span>
<span class="fc" id="L768">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L784">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L785">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L786">                        .thenApply(GetLastSessionIdResponse::getSessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L801">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L802">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L803">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">                    if (!response.isSuccess()) {</span>
<span class="nc" id="L805">                        throw new RuntimeException(</span>
<span class="nc" id="L806">                                &quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.getError());</span>
                    }
<span class="fc" id="L808">                    sessions.remove(sessionId);</span>
<span class="fc" id="L809">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L823">        return ensureConnected()</span>
<span class="fc" id="L824">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L825">                        .thenApply(ListSessionsResponse::getSessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L838">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L839">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L841">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::getSessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L857">        return ensureConnected()</span>
<span class="nc" id="L858">                .thenCompose(</span>
<span class="nc" id="L859">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L860">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L862">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                                    if (!response.isSuccess()) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">                                        throw new RuntimeException(response.getError() != null</span>
<span class="nc" id="L865">                                                ? response.getError()</span>
<span class="nc" id="L866">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L868">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L882">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L883">            lifecycleHandlers.add(handler);</span>
<span class="nc" id="L884">        }</span>
<span class="nc" id="L885">        return () -&gt; {</span>
<span class="nc" id="L886">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L887">                lifecycleHandlers.remove(handler);</span>
<span class="nc" id="L888">            }</span>
<span class="nc" id="L889">        };</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L904">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L905">            typedLifecycleHandlers.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;()).add(handler);</span>
<span class="nc" id="L906">        }</span>
<span class="nc" id="L907">        return () -&gt; {</span>
<span class="nc" id="L908">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L909">                List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="nc" id="L910">                        .get(eventType);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                if (handlers != null) {</span>
<span class="nc" id="L912">                    handlers.remove(handler);</span>
                }
<span class="nc" id="L914">            }</span>
<span class="nc" id="L915">        };</span>
    }

    void dispatchLifecycleEvent(com.github.copilot.sdk.json.SessionLifecycleEvent event) {
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; typed;
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; wildcard;

<span class="fc" id="L922">        synchronized (lifecycleHandlersLock) {</span>
<span class="fc" id="L923">            List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="fc" id="L924">                    .get(event.getType());</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">            typed = handlers != null ? new ArrayList&lt;&gt;(handlers) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L926">            wildcard = new ArrayList&lt;&gt;(lifecycleHandlers);</span>
<span class="fc" id="L927">        }</span>

<span class="pc bpc" id="L929" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : typed) {</span>
            try {
<span class="nc" id="L931">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L932">            } catch (Exception e) {</span>
<span class="nc" id="L933">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L934">            }</span>
<span class="nc" id="L935">        }</span>

<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : wildcard) {</span>
            try {
<span class="nc" id="L939">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L940">            } catch (Exception e) {</span>
<span class="nc" id="L941">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L942">            }</span>
<span class="nc" id="L943">        }</span>
<span class="fc" id="L944">    }</span>

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="pc bpc" id="L947" title="1 of 4 branches missed.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="nc" id="L948">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L951">        start();</span>
<span class="fc" id="L952">        return connectionFuture;</span>
    }

    private ProcessInfo startCliServer() throws IOException, InterruptedException {
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        String cliPath = options.getCliPath() != null ? options.getCliPath() : &quot;copilot&quot;;</span>
<span class="fc" id="L957">        var args = new ArrayList&lt;String&gt;();</span>

<span class="pc bpc" id="L959" title="1 of 2 branches missed.">        if (options.getCliArgs() != null) {</span>
<span class="nc" id="L960">            args.addAll(Arrays.asList(options.getCliArgs()));</span>
        }

<span class="fc" id="L963">        args.add(&quot;--server&quot;);</span>
<span class="fc" id="L964">        args.add(&quot;--log-level&quot;);</span>
<span class="fc" id="L965">        args.add(options.getLogLevel());</span>

<span class="fc bfc" id="L967" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="fc" id="L968">            args.add(&quot;--stdio&quot;);</span>
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">        } else if (options.getPort() &gt; 0) {</span>
<span class="nc" id="L970">            args.add(&quot;--port&quot;);</span>
<span class="nc" id="L971">            args.add(String.valueOf(options.getPort()));</span>
        }

        // Add auth-related flags
<span class="pc bpc" id="L975" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L976">            args.add(&quot;--auth-token-env&quot;);</span>
<span class="fc" id="L977">            args.add(&quot;COPILOT_SDK_AUTH_TOKEN&quot;);</span>
        }

        // Default UseLoggedInUser to false when GithubToken is provided
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">        boolean useLoggedInUser = options.getUseLoggedInUser() != null</span>
<span class="nc" id="L982">                ? options.getUseLoggedInUser()</span>
<span class="pc bpc" id="L983" title="1 of 4 branches missed.">                : (options.getGithubToken() == null || options.getGithubToken().isEmpty());</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">        if (!useLoggedInUser) {</span>
<span class="fc" id="L985">            args.add(&quot;--no-auto-login&quot;);</span>
        }

<span class="fc" id="L988">        List&lt;String&gt; command = resolveCliCommand(cliPath, args);</span>

<span class="fc" id="L990">        var pb = new ProcessBuilder(command);</span>
<span class="fc" id="L991">        pb.redirectErrorStream(false);</span>

<span class="fc bfc" id="L993" title="All 2 branches covered.">        if (options.getCwd() != null) {</span>
<span class="fc" id="L994">            pb.directory(new File(options.getCwd()));</span>
        }

<span class="fc bfc" id="L997" title="All 2 branches covered.">        if (options.getEnvironment() != null) {</span>
<span class="fc" id="L998">            pb.environment().clear();</span>
<span class="fc" id="L999">            pb.environment().putAll(options.getEnvironment());</span>
        }
<span class="fc" id="L1001">        pb.environment().remove(&quot;NODE_DEBUG&quot;);</span>

        // Set auth token in environment if provided
<span class="pc bpc" id="L1004" title="1 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L1005">            pb.environment().put(&quot;COPILOT_SDK_AUTH_TOKEN&quot;, options.getGithubToken());</span>
        }

<span class="fc" id="L1008">        Process process = pb.start();</span>

        // Forward stderr to logger in background
<span class="fc" id="L1011">        var stderrThread = new Thread(() -&gt; {</span>
<span class="fc" id="L1012">            try (BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1013">                    new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8))) {</span>
                String line;
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">                while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L1016">                    LOG.fine(&quot;[CLI] &quot; + line);</span>
                }
<span class="nc" id="L1018">            } catch (IOException e) {</span>
<span class="nc" id="L1019">                LOG.log(Level.FINE, &quot;Error reading stderr&quot;, e);</span>
<span class="fc" id="L1020">            }</span>
<span class="fc" id="L1021">        }, &quot;cli-stderr-reader&quot;);</span>
<span class="fc" id="L1022">        stderrThread.setDaemon(true);</span>
<span class="fc" id="L1023">        stderrThread.start();</span>

<span class="fc" id="L1025">        Integer detectedPort = null;</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">        if (!options.isUseStdio()) {</span>
            // Wait for port announcement
<span class="fc" id="L1028">            try (BufferedReader reader = new BufferedReader(</span>
<span class="fc" id="L1029">                    new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {</span>
<span class="fc" id="L1030">                Pattern portPattern = Pattern.compile(&quot;listening on port (\\d+)&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L1031">                long deadline = System.currentTimeMillis() + 30000;</span>

<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">                while (System.currentTimeMillis() &lt; deadline) {</span>
<span class="fc" id="L1034">                    String line = reader.readLine();</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">                    if (line == null) {</span>
<span class="nc" id="L1036">                        throw new IOException(&quot;CLI process exited unexpectedly&quot;);</span>
                    }

<span class="fc" id="L1039">                    Matcher matcher = portPattern.matcher(line);</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">                    if (matcher.find()) {</span>
<span class="fc" id="L1041">                        detectedPort = Integer.parseInt(matcher.group(1));</span>
<span class="fc" id="L1042">                        break;</span>
                    }
<span class="nc" id="L1044">                }</span>

<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">                if (detectedPort == null) {</span>
<span class="nc" id="L1047">                    process.destroyForcibly();</span>
<span class="nc" id="L1048">                    throw new IOException(&quot;Timeout waiting for CLI to announce port&quot;);</span>
                }
            }
        }

<span class="fc" id="L1053">        return new ProcessInfo(process, detectedPort);</span>
    }

    private List&lt;String&gt; resolveCliCommand(String cliPath, List&lt;String&gt; args) {
<span class="fc" id="L1057">        boolean isJsFile = cliPath.toLowerCase().endsWith(&quot;.js&quot;);</span>

<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">        if (isJsFile) {</span>
<span class="fc" id="L1060">            var result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1061">            result.add(&quot;node&quot;);</span>
<span class="fc" id="L1062">            result.add(cliPath);</span>
<span class="fc" id="L1063">            result.addAll(args);</span>
<span class="fc" id="L1064">            return result;</span>
        }

        // On Windows, use cmd /c to resolve the executable
<span class="nc" id="L1068">        String os = System.getProperty(&quot;os.name&quot;).toLowerCase();</span>
<span class="nc bnc" id="L1069" title="All 4 branches missed.">        if (os.contains(&quot;win&quot;) &amp;&amp; !new File(cliPath).isAbsolute()) {</span>
<span class="nc" id="L1070">            var result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1071">            result.add(&quot;cmd&quot;);</span>
<span class="nc" id="L1072">            result.add(&quot;/c&quot;);</span>
<span class="nc" id="L1073">            result.add(cliPath);</span>
<span class="nc" id="L1074">            result.addAll(args);</span>
<span class="nc" id="L1075">            return result;</span>
        }

<span class="nc" id="L1078">        var result = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1079">        result.add(cliPath);</span>
<span class="nc" id="L1080">        result.addAll(args);</span>
<span class="nc" id="L1081">        return result;</span>
    }

    private Connection connectToServer(Process process, String tcpHost, Integer tcpPort) throws IOException {
        JsonRpcClient rpc;

<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if (options.isUseStdio()) {</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">            if (process == null) {</span>
<span class="nc" id="L1089">                throw new IllegalStateException(&quot;CLI process not started&quot;);</span>
            }
<span class="fc" id="L1091">            rpc = JsonRpcClient.fromProcess(process);</span>
        } else {
<span class="pc bpc" id="L1093" title="2 of 4 branches missed.">            if (tcpHost == null || tcpPort == null) {</span>
<span class="nc" id="L1094">                throw new IllegalStateException(&quot;Cannot connect because TCP host or port are not available&quot;);</span>
            }
<span class="fc" id="L1096">            Socket socket = new Socket(tcpHost, tcpPort);</span>
<span class="fc" id="L1097">            rpc = JsonRpcClient.fromSocket(socket);</span>
        }

<span class="fc" id="L1100">        return new Connection(rpc, process);</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">        if (disposed)</span>
<span class="nc" id="L1106">            return;</span>
<span class="fc" id="L1107">        disposed = true;</span>
        try {
<span class="fc" id="L1109">            forceStop().get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L1110">        } catch (Exception e) {</span>
<span class="nc" id="L1111">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L1112">        }</span>
<span class="fc" id="L1113">    }</span>

<span class="fc" id="L1115">    private static record ProcessInfo(Process process, Integer port) {</span>
    };

<span class="fc" id="L1118">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>