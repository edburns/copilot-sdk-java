<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionLifecycleHandler;
import com.github.copilot.sdk.json.SessionMetadata;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (var client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(AssistantMessageEvent.class, msg -&gt; {
 * 		System.out.println(msg.getData().getContent());
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public final class CopilotClient implements AutoCloseable {

<span class="fc" id="L62">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>

    private final CopilotClientOptions options;
    private final CliServerManager serverManager;
<span class="fc" id="L66">    private final LifecycleEventManager lifecycleManager = new LifecycleEventManager();</span>
<span class="fc" id="L67">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L69">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L73">    private final Object modelsCacheLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L79">        this(new CopilotClientOptions());</span>
<span class="fc" id="L80">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L90">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // Validate mutually exclusive options
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">                &amp;&amp; (this.options.isUseStdio() || this.options.getCliPath() != null)) {</span>
<span class="fc" id="L96">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with UseStdio and CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L100" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L102">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L107" title="3 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="nc" id="L108">            URI uri = CliServerManager.parseCliUrl(this.options.getCliUrl());</span>
<span class="nc" id="L109">            this.optionsHost = uri.getHost();</span>
<span class="nc" id="L110">            this.optionsPort = uri.getPort();</span>
<span class="nc" id="L111">        } else {</span>
<span class="fc" id="L112">            this.optionsHost = null;</span>
<span class="fc" id="L113">            this.optionsPort = null;</span>
        }

<span class="fc" id="L116">        this.serverManager = new CliServerManager(this.options);</span>
<span class="fc" id="L117">    }</span>

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L126">            synchronized (this) {</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L128">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L130">            }</span>
        }
<span class="fc" id="L132">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L136">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L138">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                JsonRpcClient rpc;
<span class="fc" id="L141">                Process process = null;</span>

<span class="pc bpc" id="L143" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L145">                    rpc = serverManager.connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L148">                    CliServerManager.ProcessInfo processInfo = serverManager.startCliServer();</span>
<span class="fc" id="L149">                    process = processInfo.process();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">                    rpc = serverManager.connectToServer(process, processInfo.port() != null ? &quot;localhost&quot; : null,</span>
<span class="fc" id="L151">                            processInfo.port());</span>
                }

<span class="fc" id="L154">                Connection connection = new Connection(rpc, process);</span>

                // Register handlers for server-to-client calls
<span class="fc" id="L157">                RpcHandlerDispatcher dispatcher = new RpcHandlerDispatcher(sessions, lifecycleManager::dispatch);</span>
<span class="fc" id="L158">                dispatcher.registerHandlers(rpc);</span>

                // Verify protocol version
<span class="fc" id="L161">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L163">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L164">                return connection;</span>
<span class="nc" id="L165">            } catch (Exception e) {</span>
<span class="nc" id="L166">                throw new CompletionException(e);</span>
            }
        });
    }

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L172">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L173">        var params = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L174">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L175">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() == null) {</span>
<span class="nc" id="L178">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() != expectedVersion) {</span>
<span class="nc" id="L184">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L185">                    + &quot;, but server reports version &quot; + pingResponse.getProtocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L188">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="fc" id="L196">        var closeFutures = new ArrayList&lt;CompletableFuture&lt;Void&gt;&gt;();</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="nc" id="L199">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="nc" id="L201">                    session.close();</span>
<span class="nc" id="L202">                } catch (Exception e) {</span>
<span class="nc" id="L203">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="nc" id="L204">                }</span>
<span class="nc" id="L205">            }));</span>
<span class="nc" id="L206">        }</span>
<span class="fc" id="L207">        sessions.clear();</span>

<span class="fc" id="L209">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="fc" id="L210">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L219">        sessions.clear();</span>
<span class="fc" id="L220">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L224">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L225">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L228">        modelsCache = null;</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L231">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L234">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L236">                connection.rpc.close();</span>
<span class="nc" id="L237">            } catch (Exception e) {</span>
<span class="nc" id="L238">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L239">            }</span>

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L244">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L246">                } catch (Exception e) {</span>
<span class="nc" id="L247">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L248">                }</span>
            }
<span class="pc" id="L250">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L266">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L267">            var request = SessionRequestBuilder.buildCreateRequest(config);</span>

<span class="fc" id="L269">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L270">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="fc" id="L271">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L272">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L273">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L285">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L304">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L305">            var request = SessionRequestBuilder.buildResumeRequest(sessionId, config);</span>

<span class="fc" id="L307">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L308">                var session = new CopilotSession(response.getSessionId(), connection.rpc, response.getWorkspacePath());</span>
<span class="fc" id="L309">                SessionRequestBuilder.configureSession(session, config);</span>
<span class="fc" id="L310">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L311">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L325">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (connectionFuture == null)</span>
<span class="fc" id="L336">            return ConnectionState.DISCONNECTED;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="nc" id="L338">            return ConnectionState.ERROR;</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">        if (!connectionFuture.isDone())</span>
<span class="nc" id="L340">            return ConnectionState.CONNECTING;</span>
<span class="fc" id="L341">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="fc" id="L356">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="fc" id="L368">        return ensureConnected()</span>
<span class="fc" id="L369">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="fc" id="L379">        return ensureConnected().thenCompose(</span>
<span class="fc" id="L380">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="fc" id="L394">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L396">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="fc" id="L399">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="fc" id="L401">            synchronized (modelsCacheLock) {</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L403">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="fc" id="L405">            }</span>

<span class="fc" id="L407">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L408">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="fc" id="L409">                synchronized (modelsCacheLock) {</span>
<span class="fc" id="L410">                    modelsCache = models;</span>
<span class="fc" id="L411">                }</span>
<span class="fc" id="L412">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L428">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L429">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L430">                        .thenApply(GetLastSessionIdResponse::getSessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L445">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L446">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L447">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                    if (!response.isSuccess()) {</span>
<span class="nc" id="L449">                        throw new RuntimeException(</span>
<span class="nc" id="L450">                                &quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.getError());</span>
                    }
<span class="fc" id="L452">                    sessions.remove(sessionId);</span>
<span class="fc" id="L453">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L467">        return ensureConnected()</span>
<span class="fc" id="L468">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L469">                        .thenApply(ListSessionsResponse::getSessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L482">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L483">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L485">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::getSessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L501">        return ensureConnected()</span>
<span class="nc" id="L502">                .thenCompose(</span>
<span class="nc" id="L503">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L504">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L506">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                                    if (!response.isSuccess()) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                                        throw new RuntimeException(response.getError() != null</span>
<span class="nc" id="L509">                                                ? response.getError()</span>
<span class="nc" id="L510">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L512">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(SessionLifecycleHandler handler) {
<span class="nc" id="L526">        return lifecycleManager.subscribe(handler);</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, SessionLifecycleHandler handler) {
<span class="nc" id="L541">        return lifecycleManager.subscribe(eventType, handler);</span>
    }

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="pc bpc" id="L545" title="1 of 4 branches missed.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="nc" id="L546">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L549">        start();</span>
<span class="fc" id="L550">        return connectionFuture;</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">        if (disposed)</span>
<span class="nc" id="L556">            return;</span>
<span class="fc" id="L557">        disposed = true;</span>
        try {
<span class="fc" id="L559">            forceStop().get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L560">        } catch (Exception e) {</span>
<span class="nc" id="L561">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">    }</span>

<span class="fc" id="L565">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>