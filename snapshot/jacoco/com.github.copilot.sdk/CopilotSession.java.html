<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotSession.java</span></div><h1>CopilotSession.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.AssistantMessageEvent;
import com.github.copilot.sdk.events.SessionErrorEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.events.SessionIdleEvent;
import com.github.copilot.sdk.json.GetMessagesResponse;
import com.github.copilot.sdk.json.HookInvocation;
import com.github.copilot.sdk.json.MessageOptions;
import com.github.copilot.sdk.json.PermissionHandler;
import com.github.copilot.sdk.json.PermissionInvocation;
import com.github.copilot.sdk.json.PermissionRequest;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PostToolUseHookInput;
import com.github.copilot.sdk.json.PreToolUseHookInput;
import com.github.copilot.sdk.json.SendMessageRequest;
import com.github.copilot.sdk.json.SendMessageResponse;
import com.github.copilot.sdk.json.SessionEndHookInput;
import com.github.copilot.sdk.json.SessionHooks;
import com.github.copilot.sdk.json.SessionStartHookInput;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.UserInputHandler;
import com.github.copilot.sdk.json.UserInputInvocation;
import com.github.copilot.sdk.json.UserInputRequest;
import com.github.copilot.sdk.json.UserInputResponse;
import com.github.copilot.sdk.json.UserPromptSubmittedHookInput;

/**
 * Represents a single conversation session with the Copilot CLI.
 * &lt;p&gt;
 * A session maintains conversation state, handles events, and manages tool
 * execution. Sessions are created via {@link CopilotClient#createSession} or
 * resumed via {@link CopilotClient#resumeSession}.
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create a session
 * var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * // Register type-safe event handlers
 * session.on(AssistantMessageEvent.class, msg -&gt; {
 * 	System.out.println(msg.getData().getContent());
 * });
 * session.on(SessionIdleEvent.class, idle -&gt; {
 * 	System.out.println(&quot;Session is idle&quot;);
 * });
 *
 * // Send messages
 * session.sendAndWait(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 *
 * // Clean up
 * session.close();
 * }&lt;/pre&gt;
 *
 * @see CopilotClient#createSession(com.github.copilot.sdk.json.SessionConfig)
 * @see CopilotClient#resumeSession(String,
 *      com.github.copilot.sdk.json.ResumeSessionConfig)
 * @see AbstractSessionEvent
 * @since 1.0.0
 */
public final class CopilotSession implements AutoCloseable {

<span class="fc" id="L87">    private static final Logger LOG = Logger.getLogger(CopilotSession.class.getName());</span>
<span class="fc" id="L88">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final String sessionId;
    private final String workspacePath;
    private final JsonRpcClient rpc;
<span class="fc" id="L93">    private final Set&lt;Consumer&lt;AbstractSessionEvent&gt;&gt; eventHandlers = ConcurrentHashMap.newKeySet();</span>
<span class="fc" id="L94">    private final Map&lt;String, ToolDefinition&gt; toolHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">    private final AtomicReference&lt;PermissionHandler&gt; permissionHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L96">    private final AtomicReference&lt;UserInputHandler&gt; userInputHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L97">    private final AtomicReference&lt;SessionHooks&gt; hooksHandler = new AtomicReference&lt;&gt;();</span>
    private volatile EventErrorHandler eventErrorHandler;

    /**
     * Creates a new session with the given ID and RPC client.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     */
    CopilotSession(String sessionId, JsonRpcClient rpc) {
<span class="nc" id="L112">        this(sessionId, rpc, null);</span>
<span class="nc" id="L113">    }</span>

    /**
     * Creates a new session with the given ID, RPC client, and workspace path.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     * @param workspacePath
     *            the workspace path if infinite sessions are enabled
     */
<span class="fc" id="L128">    CopilotSession(String sessionId, JsonRpcClient rpc, String workspacePath) {</span>
<span class="fc" id="L129">        this.sessionId = sessionId;</span>
<span class="fc" id="L130">        this.rpc = rpc;</span>
<span class="fc" id="L131">        this.workspacePath = workspacePath;</span>
<span class="fc" id="L132">    }</span>

    /**
     * Gets the unique identifier for this session.
     *
     * @return the session ID
     */
    public String getSessionId() {
<span class="fc" id="L140">        return sessionId;</span>
    }

    /**
     * Gets the path to the session workspace directory when infinite sessions are
     * enabled.
     * &lt;p&gt;
     * The workspace directory contains checkpoints/, plan.md, and files/
     * subdirectories.
     *
     * @return the workspace path, or {@code null} if infinite sessions are disabled
     */
    public String getWorkspacePath() {
<span class="nc" id="L153">        return workspacePath;</span>
    }

    /**
     * Sets a custom error handler for exceptions thrown by event handlers.
     * &lt;p&gt;
     * When an event handler registered via {@link #on(Consumer)} or
     * {@link #on(Class, Consumer)} throws an exception during event dispatch, the
     * error handler is invoked instead of the default behavior (logging at
     * {@link Level#SEVERE}).
     *
     * &lt;p&gt;
     * If the error handler itself throws an exception, that exception is silently
     * caught and logged to prevent cascading failures.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * session.setEventErrorHandler((event, exception) -&gt; {
     * 	metrics.increment(&quot;handler.errors&quot;);
     * 	logger.error(&quot;Handler failed on {}: {}&quot;, event.getType(), exception.getMessage());
     * });
     * }&lt;/pre&gt;
     *
     * @param handler
     *            the error handler, or {@code null} to restore default logging
     *            behavior
     * @see EventErrorHandler
     * @since 1.0.8
     */
    public void setEventErrorHandler(EventErrorHandler handler) {
<span class="fc" id="L185">        this.eventErrorHandler = handler;</span>
<span class="fc" id="L186">    }</span>

    /**
     * Sends a simple text message to the Copilot session.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code send(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the message ID assigned by the server
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;String&gt; send(String prompt) {
<span class="nc" id="L200">        return send(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a simple text message and waits until the session becomes idle.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code sendAndWait(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @see #sendAndWait(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(String prompt) {
<span class="nc" id="L216">        return sendAndWait(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a message to the Copilot session.
     * &lt;p&gt;
     * This method sends a message asynchronously and returns immediately. Use
     * {@link #sendAndWait(MessageOptions)} to wait for the response.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the message ID assigned by the server
     * @see #sendAndWait(MessageOptions)
     * @see #send(String)
     */
    public CompletableFuture&lt;String&gt; send(MessageOptions options) {
<span class="fc" id="L232">        var request = new SendMessageRequest();</span>
<span class="fc" id="L233">        request.setSessionId(sessionId);</span>
<span class="fc" id="L234">        request.setPrompt(options.getPrompt());</span>
<span class="fc" id="L235">        request.setAttachments(options.getAttachments());</span>
<span class="fc" id="L236">        request.setMode(options.getMode());</span>

<span class="fc" id="L238">        return rpc.invoke(&quot;session.send&quot;, request, SendMessageResponse.class)</span>
<span class="fc" id="L239">                .thenApply(SendMessageResponse::getMessageId);</span>
    }

    /**
     * Sends a message and waits until the session becomes idle.
     * &lt;p&gt;
     * This method blocks until the assistant finishes processing the message or
     * until the timeout expires. It's suitable for simple request/response
     * interactions where you don't need to process streaming events.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @param timeoutMs
     *            timeout in milliseconds (0 or negative for no timeout)
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received. The future
     *         completes exceptionally with a TimeoutException if the timeout
     *         expires.
     * @see #sendAndWait(MessageOptions)
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options, long timeoutMs) {
<span class="fc" id="L261">        var future = new CompletableFuture&lt;AssistantMessageEvent&gt;();</span>
<span class="fc" id="L262">        var lastAssistantMessage = new AtomicReference&lt;AssistantMessageEvent&gt;();</span>

<span class="fc" id="L264">        Consumer&lt;AbstractSessionEvent&gt; handler = evt -&gt; {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (evt instanceof AssistantMessageEvent msg) {</span>
<span class="fc" id="L266">                lastAssistantMessage.set(msg);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            } else if (evt instanceof SessionIdleEvent) {</span>
<span class="fc" id="L268">                future.complete(lastAssistantMessage.get());</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">            } else if (evt instanceof SessionErrorEvent errorEvent) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                String message = errorEvent.getData() != null ? errorEvent.getData().getMessage() : &quot;session error&quot;;</span>
<span class="nc" id="L271">                future.completeExceptionally(new RuntimeException(&quot;Session error: &quot; + message));</span>
            }
<span class="fc" id="L273">        };</span>

<span class="fc" id="L275">        Closeable subscription = on(handler);</span>

<span class="fc" id="L277">        send(options).exceptionally(ex -&gt; {</span>
            try {
<span class="nc" id="L279">                subscription.close();</span>
<span class="nc" id="L280">            } catch (Exception e) {</span>
<span class="nc" id="L281">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="nc" id="L282">            }</span>
<span class="nc" id="L283">            future.completeExceptionally(ex);</span>
<span class="nc" id="L284">            return null;</span>
        });

        // Set up timeout with daemon thread so it doesn't prevent JVM exit
<span class="fc" id="L288">        var scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; {</span>
<span class="fc" id="L289">            var t = new Thread(r, &quot;sendAndWait-timeout&quot;);</span>
<span class="fc" id="L290">            t.setDaemon(true);</span>
<span class="fc" id="L291">            return t;</span>
        });
<span class="fc" id="L293">        scheduler.schedule(() -&gt; {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">            if (!future.isDone()) {</span>
<span class="fc" id="L295">                future.completeExceptionally(new TimeoutException(&quot;sendAndWait timed out after &quot; + timeoutMs + &quot;ms&quot;));</span>
            }
<span class="fc" id="L297">            scheduler.shutdown();</span>
<span class="fc" id="L298">        }, timeoutMs, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L300">        return future.whenComplete((result, ex) -&gt; {</span>
            try {
<span class="fc" id="L302">                subscription.close();</span>
<span class="nc" id="L303">            } catch (IOException e) {</span>
<span class="nc" id="L304">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="fc" id="L305">            }</span>
<span class="fc" id="L306">            scheduler.shutdown();</span>
<span class="fc" id="L307">        });</span>
    }

    /**
     * Sends a message and waits until the session becomes idle with default 60
     * second timeout.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @see #sendAndWait(MessageOptions, long)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options) {
<span class="fc" id="L321">        return sendAndWait(options, 60000);</span>
    }

    /**
     * Registers a callback for all session events.
     * &lt;p&gt;
     * The handler will be invoked for every event in this session, including
     * assistant messages, tool calls, and session state changes. For type-safe
     * handling of specific event types, prefer {@link #on(Class, Consumer)}
     * instead.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception isolation:&lt;/b&gt; If a handler throws an exception, the error is
     * logged and remaining handlers still execute.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * // Collect all events
     * var events = new ArrayList&lt;AbstractSessionEvent&gt;();
     * session.on(events::add);
     * }&lt;/pre&gt;
     *
     * @param handler
     *            a callback to be invoked when a session event occurs
     * @return a Closeable that, when closed, unsubscribes the handler
     * @see #on(Class, Consumer)
     * @see AbstractSessionEvent
     */
    public Closeable on(Consumer&lt;AbstractSessionEvent&gt; handler) {
<span class="fc" id="L352">        eventHandlers.add(handler);</span>
<span class="fc" id="L353">        return () -&gt; eventHandlers.remove(handler);</span>
    }

    /**
     * Registers an event handler for a specific event type.
     * &lt;p&gt;
     * This provides a type-safe way to handle specific events without needing
     * {@code instanceof} checks. The handler will only be called for events
     * matching the specified type.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception isolation:&lt;/b&gt; If a handler throws an exception, the error is
     * logged and remaining handlers still execute.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example Usage&lt;/b&gt;
     * &lt;/p&gt;
     *
     * &lt;pre&gt;{@code
     * // Handle assistant messages
     * session.on(AssistantMessageEvent.class, msg -&gt; {
     * 	System.out.println(msg.getData().getContent());
     * });
     *
     * // Handle session idle
     * session.on(SessionIdleEvent.class, idle -&gt; {
     * 	done.complete(null);
     * });
     *
     * // Handle streaming deltas
     * session.on(AssistantMessageDeltaEvent.class, delta -&gt; {
     * 	System.out.print(delta.getData().getDeltaContent());
     * });
     * }&lt;/pre&gt;
     *
     * @param &lt;T&gt;
     *            the event type
     * @param eventType
     *            the class of the event to listen for
     * @param handler
     *            a callback invoked when events of this type occur
     * @return a Closeable that unsubscribes the handler when closed
     * @see #on(Consumer)
     * @see AbstractSessionEvent
     */
    public &lt;T extends AbstractSessionEvent&gt; Closeable on(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler) {
<span class="fc" id="L399">        Consumer&lt;AbstractSessionEvent&gt; wrapper = event -&gt; {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (eventType.isInstance(event)) {</span>
<span class="fc" id="L401">                handler.accept(eventType.cast(event));</span>
            }
<span class="fc" id="L403">        };</span>
<span class="fc" id="L404">        eventHandlers.add(wrapper);</span>
<span class="fc" id="L405">        return () -&gt; eventHandlers.remove(wrapper);</span>
    }

    /**
     * Dispatches an event to all registered handlers.
     * &lt;p&gt;
     * This is called internally when events are received from the server. Each
     * handler is invoked in its own try/catch block so that an exception thrown by
     * one handler does not prevent subsequent handlers from executing.
     * &lt;p&gt;
     * If a custom {@link EventErrorHandler} has been set via
     * {@link #setEventErrorHandler(EventErrorHandler)}, it is called with the event
     * and exception. Otherwise, exceptions are logged at {@link Level#SEVERE}.
     *
     * @param event
     *            the event to dispatch
     * @see #setEventErrorHandler(EventErrorHandler)
     */
    void dispatchEvent(AbstractSessionEvent event) {
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (Consumer&lt;AbstractSessionEvent&gt; handler : eventHandlers) {</span>
            try {
<span class="fc" id="L426">                handler.accept(event);</span>
<span class="fc" id="L427">            } catch (Exception e) {</span>
<span class="fc" id="L428">                EventErrorHandler errorHandler = this.eventErrorHandler;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                if (errorHandler != null) {</span>
                    try {
<span class="fc" id="L431">                        errorHandler.handleError(event, e);</span>
<span class="fc" id="L432">                    } catch (Exception errorHandlerException) {</span>
<span class="fc" id="L433">                        LOG.log(Level.SEVERE, &quot;Error in event error handler&quot;, errorHandlerException);</span>
<span class="fc" id="L434">                    }</span>
                } else {
<span class="fc" id="L436">                    LOG.log(Level.SEVERE, &quot;Error in event handler&quot;, e);</span>
                }
<span class="fc" id="L438">            }</span>
<span class="fc" id="L439">        }</span>
<span class="fc" id="L440">    }</span>

    /**
     * Registers custom tool handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with tools.
     *
     * @param tools
     *            the list of tool definitions with handlers
     */
    void registerTools(List&lt;ToolDefinition&gt; tools) {
<span class="fc" id="L451">        toolHandlers.clear();</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">        if (tools != null) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            for (ToolDefinition tool : tools) {</span>
<span class="fc" id="L454">                toolHandlers.put(tool.getName(), tool);</span>
<span class="fc" id="L455">            }</span>
        }
<span class="fc" id="L457">    }</span>

    /**
     * Retrieves a registered tool by name.
     *
     * @param name
     *            the tool name
     * @return the tool definition, or {@code null} if not found
     */
    ToolDefinition getTool(String name) {
<span class="fc" id="L467">        return toolHandlers.get(name);</span>
    }

    /**
     * Registers a handler for permission requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with permission
     * handling.
     *
     * @param handler
     *            the permission handler
     */
    void registerPermissionHandler(PermissionHandler handler) {
<span class="fc" id="L480">        permissionHandler.set(handler);</span>
<span class="fc" id="L481">    }</span>

    /**
     * Handles a permission request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests permission for an operation.
     *
     * @param permissionRequestData
     *            the JSON data for the permission request
     * @return a future that resolves with the permission result
     */
    CompletableFuture&lt;PermissionRequestResult&gt; handlePermissionRequest(JsonNode permissionRequestData) {
<span class="fc" id="L493">        PermissionHandler handler = permissionHandler.get();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L495">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="nc" id="L496">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L497">            return CompletableFuture.completedFuture(result);</span>
        }

        try {
<span class="fc" id="L501">            PermissionRequest request = MAPPER.treeToValue(permissionRequestData, PermissionRequest.class);</span>
<span class="fc" id="L502">            var invocation = new PermissionInvocation();</span>
<span class="fc" id="L503">            invocation.setSessionId(sessionId);</span>
<span class="fc" id="L504">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="nc" id="L505">                LOG.log(Level.SEVERE, &quot;Permission handler threw an exception&quot;, ex);</span>
<span class="nc" id="L506">                PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="nc" id="L507">                result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L508">                return result;</span>
            });
<span class="fc" id="L510">        } catch (Exception e) {</span>
<span class="fc" id="L511">            LOG.log(Level.SEVERE, &quot;Failed to process permission request&quot;, e);</span>
<span class="fc" id="L512">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="fc" id="L513">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="fc" id="L514">            return CompletableFuture.completedFuture(result);</span>
        }
    }

    /**
     * Registers a handler for user input requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with user input
     * handling.
     *
     * @param handler
     *            the user input handler
     */
    void registerUserInputHandler(UserInputHandler handler) {
<span class="fc" id="L528">        userInputHandler.set(handler);</span>
<span class="fc" id="L529">    }</span>

    /**
     * Handles a user input request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests user input.
     *
     * @param request
     *            the user input request
     * @return a future that resolves with the user input response
     */
    CompletableFuture&lt;UserInputResponse&gt; handleUserInputRequest(UserInputRequest request) {
<span class="fc" id="L541">        UserInputHandler handler = userInputHandler.get();</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L543">            return CompletableFuture.failedFuture(new IllegalStateException(&quot;No user input handler registered&quot;));</span>
        }

        try {
<span class="fc" id="L547">            var invocation = new UserInputInvocation().setSessionId(sessionId);</span>
<span class="fc" id="L548">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="nc" id="L549">                LOG.log(Level.SEVERE, &quot;User input handler threw an exception&quot;, ex);</span>
<span class="nc" id="L550">                throw new RuntimeException(&quot;User input handler error&quot;, ex);</span>
            });
<span class="nc" id="L552">        } catch (Exception e) {</span>
<span class="nc" id="L553">            LOG.log(Level.SEVERE, &quot;Failed to process user input request&quot;, e);</span>
<span class="nc" id="L554">            return CompletableFuture.failedFuture(e);</span>
        }
    }

    /**
     * Registers hook handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with hooks.
     *
     * @param hooks
     *            the hooks configuration
     */
    void registerHooks(SessionHooks hooks) {
<span class="fc" id="L567">        hooksHandler.set(hooks);</span>
<span class="fc" id="L568">    }</span>

    /**
     * Handles a hook invocation from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server invokes a hook.
     *
     * @param hookType
     *            the type of hook to invoke
     * @param input
     *            the hook input data
     * @return a future that resolves with the hook output
     */
    CompletableFuture&lt;Object&gt; handleHooksInvoke(String hookType, JsonNode input) {
<span class="fc" id="L582">        SessionHooks hooks = hooksHandler.get();</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (hooks == null) {</span>
<span class="nc" id="L584">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L587">        var invocation = new HookInvocation().setSessionId(sessionId);</span>

        try {
<span class="pc bpc" id="L590" title="1 of 6 branches missed.">            switch (hookType) {</span>
                case &quot;preToolUse&quot; :
<span class="fc bfc" id="L592" title="All 2 branches covered.">                    if (hooks.getOnPreToolUse() != null) {</span>
<span class="fc" id="L593">                        PreToolUseHookInput preInput = MAPPER.treeToValue(input, PreToolUseHookInput.class);</span>
<span class="fc" id="L594">                        return hooks.getOnPreToolUse().handle(preInput, invocation)</span>
<span class="fc" id="L595">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;postToolUse&quot; :
<span class="fc bfc" id="L599" title="All 2 branches covered.">                    if (hooks.getOnPostToolUse() != null) {</span>
<span class="fc" id="L600">                        PostToolUseHookInput postInput = MAPPER.treeToValue(input, PostToolUseHookInput.class);</span>
<span class="fc" id="L601">                        return hooks.getOnPostToolUse().handle(postInput, invocation)</span>
<span class="fc" id="L602">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;userPromptSubmitted&quot; :
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                    if (hooks.getOnUserPromptSubmitted() != null) {</span>
<span class="nc" id="L607">                        UserPromptSubmittedHookInput promptInput = MAPPER.treeToValue(input,</span>
                                UserPromptSubmittedHookInput.class);
<span class="nc" id="L609">                        return hooks.getOnUserPromptSubmitted().handle(promptInput, invocation)</span>
<span class="nc" id="L610">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionStart&quot; :
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">                    if (hooks.getOnSessionStart() != null) {</span>
<span class="nc" id="L615">                        SessionStartHookInput startInput = MAPPER.treeToValue(input, SessionStartHookInput.class);</span>
<span class="nc" id="L616">                        return hooks.getOnSessionStart().handle(startInput, invocation)</span>
<span class="nc" id="L617">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionEnd&quot; :
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">                    if (hooks.getOnSessionEnd() != null) {</span>
<span class="nc" id="L622">                        SessionEndHookInput endInput = MAPPER.treeToValue(input, SessionEndHookInput.class);</span>
<span class="nc" id="L623">                        return hooks.getOnSessionEnd().handle(endInput, invocation)</span>
<span class="nc" id="L624">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                default :
<span class="nc" id="L628">                    LOG.fine(&quot;Unhandled hook type: &quot; + hookType);</span>
            }
<span class="nc" id="L630">        } catch (Exception e) {</span>
<span class="nc" id="L631">            LOG.log(Level.SEVERE, &quot;Failed to process hook invocation&quot;, e);</span>
<span class="nc" id="L632">            return CompletableFuture.failedFuture(e);</span>
<span class="fc" id="L633">        }</span>

<span class="fc" id="L635">        return CompletableFuture.completedFuture(null);</span>
    }

    /**
     * Gets the complete list of messages and events in the session.
     * &lt;p&gt;
     * This retrieves the full conversation history, including all user messages,
     * assistant responses, tool invocations, and other session events.
     *
     * @return a future that resolves with a list of all session events
     * @see AbstractSessionEvent
     */
    public CompletableFuture&lt;List&lt;AbstractSessionEvent&gt;&gt; getMessages() {
<span class="fc" id="L648">        return rpc.invoke(&quot;session.getMessages&quot;, Map.of(&quot;sessionId&quot;, sessionId), GetMessagesResponse.class)</span>
<span class="fc" id="L649">                .thenApply(response -&gt; {</span>
<span class="fc" id="L650">                    var events = new ArrayList&lt;AbstractSessionEvent&gt;();</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                    if (response.getEvents() != null) {</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">                        for (JsonNode eventNode : response.getEvents()) {</span>
                            try {
<span class="fc" id="L654">                                AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                                if (event != null) {</span>
<span class="fc" id="L656">                                    events.add(event);</span>
                                }
<span class="nc" id="L658">                            } catch (Exception e) {</span>
<span class="nc" id="L659">                                LOG.log(Level.WARNING, &quot;Failed to parse event&quot;, e);</span>
<span class="fc" id="L660">                            }</span>
<span class="fc" id="L661">                        }</span>
                    }
<span class="fc" id="L663">                    return events;</span>
                });
    }

    /**
     * Aborts the currently processing message in this session.
     * &lt;p&gt;
     * Use this to cancel a long-running operation or stop the assistant from
     * continuing to generate a response.
     *
     * @return a future that completes when the abort is acknowledged
     */
    public CompletableFuture&lt;Void&gt; abort() {
<span class="fc" id="L676">        return rpc.invoke(&quot;session.abort&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class);</span>
    }

    /**
     * Disposes the session and releases all associated resources.
     * &lt;p&gt;
     * This destroys the session on the server, clears all event handlers, and
     * releases tool and permission handlers. After calling this method, the session
     * cannot be used again.
     */
    @Override
    public void close() {
        try {
<span class="fc" id="L689">            rpc.invoke(&quot;session.destroy&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class).get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L690">        } catch (Exception e) {</span>
<span class="nc" id="L691">            LOG.log(Level.FINE, &quot;Error destroying session&quot;, e);</span>
<span class="fc" id="L692">        }</span>

<span class="fc" id="L694">        eventHandlers.clear();</span>
<span class="fc" id="L695">        toolHandlers.clear();</span>
<span class="fc" id="L696">        permissionHandler.set(null);</span>
<span class="fc" id="L697">        userInputHandler.set(null);</span>
<span class="fc" id="L698">        hooksHandler.set(null);</span>
<span class="fc" id="L699">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>