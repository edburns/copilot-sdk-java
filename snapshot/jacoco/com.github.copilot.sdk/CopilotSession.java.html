<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotSession.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotSession.java</span></div><h1>CopilotSession.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.AssistantMessageEvent;
import com.github.copilot.sdk.events.SessionErrorEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.events.SessionIdleEvent;
import com.github.copilot.sdk.json.GetMessagesResponse;
import com.github.copilot.sdk.json.HookInvocation;
import com.github.copilot.sdk.json.MessageOptions;
import com.github.copilot.sdk.json.PermissionHandler;
import com.github.copilot.sdk.json.PermissionInvocation;
import com.github.copilot.sdk.json.PermissionRequest;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PostToolUseHookInput;
import com.github.copilot.sdk.json.PreToolUseHookInput;
import com.github.copilot.sdk.json.SendMessageRequest;
import com.github.copilot.sdk.json.SendMessageResponse;
import com.github.copilot.sdk.json.SessionEndHookInput;
import com.github.copilot.sdk.json.SessionHooks;
import com.github.copilot.sdk.json.SessionStartHookInput;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.UserInputHandler;
import com.github.copilot.sdk.json.UserInputInvocation;
import com.github.copilot.sdk.json.UserInputRequest;
import com.github.copilot.sdk.json.UserInputResponse;
import com.github.copilot.sdk.json.UserPromptSubmittedHookInput;

/**
 * Represents a single conversation session with the Copilot CLI.
 * &lt;p&gt;
 * A session maintains conversation state, handles events, and manages tool
 * execution. Sessions are created via {@link CopilotClient#createSession} or
 * resumed via {@link CopilotClient#resumeSession}.
 *
 * &lt;h2&gt;Example Usage&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Create a session
 * var session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * // Register type-safe event handlers
 * session.on(AssistantMessageEvent.class, msg -&gt; {
 * 	System.out.println(msg.getData().getContent());
 * });
 * session.on(SessionIdleEvent.class, idle -&gt; {
 * 	System.out.println(&quot;Session is idle&quot;);
 * });
 *
 * // Send messages
 * session.sendAndWait(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 *
 * // Clean up
 * session.close();
 * }&lt;/pre&gt;
 *
 * @see CopilotClient#createSession(com.github.copilot.sdk.json.SessionConfig)
 * @see CopilotClient#resumeSession(String,
 *      com.github.copilot.sdk.json.ResumeSessionConfig)
 * @see AbstractSessionEvent
 * @since 1.0.0
 */
public final class CopilotSession implements AutoCloseable {

<span class="fc" id="L87">    private static final Logger LOG = Logger.getLogger(CopilotSession.class.getName());</span>
<span class="fc" id="L88">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final String sessionId;
    private final String workspacePath;
    private final JsonRpcClient rpc;
<span class="fc" id="L93">    private final Set&lt;Consumer&lt;AbstractSessionEvent&gt;&gt; eventHandlers = ConcurrentHashMap.newKeySet();</span>
<span class="fc" id="L94">    private final Map&lt;String, ToolDefinition&gt; toolHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">    private final AtomicReference&lt;PermissionHandler&gt; permissionHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L96">    private final AtomicReference&lt;UserInputHandler&gt; userInputHandler = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L97">    private final AtomicReference&lt;SessionHooks&gt; hooksHandler = new AtomicReference&lt;&gt;();</span>
    private volatile EventErrorHandler eventErrorHandler;
<span class="fc" id="L99">    private volatile EventErrorPolicy eventErrorPolicy = EventErrorPolicy.PROPAGATE_AND_LOG_ERRORS;</span>

    /**
     * Creates a new session with the given ID and RPC client.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     */
    CopilotSession(String sessionId, JsonRpcClient rpc) {
<span class="nc" id="L113">        this(sessionId, rpc, null);</span>
<span class="nc" id="L114">    }</span>

    /**
     * Creates a new session with the given ID, RPC client, and workspace path.
     * &lt;p&gt;
     * This constructor is package-private. Sessions should be created via
     * {@link CopilotClient#createSession} or {@link CopilotClient#resumeSession}.
     *
     * @param sessionId
     *            the unique session identifier
     * @param rpc
     *            the JSON-RPC client for communication
     * @param workspacePath
     *            the workspace path if infinite sessions are enabled
     */
<span class="fc" id="L129">    CopilotSession(String sessionId, JsonRpcClient rpc, String workspacePath) {</span>
<span class="fc" id="L130">        this.sessionId = sessionId;</span>
<span class="fc" id="L131">        this.rpc = rpc;</span>
<span class="fc" id="L132">        this.workspacePath = workspacePath;</span>
<span class="fc" id="L133">    }</span>

    /**
     * Gets the unique identifier for this session.
     *
     * @return the session ID
     */
    public String getSessionId() {
<span class="fc" id="L141">        return sessionId;</span>
    }

    /**
     * Gets the path to the session workspace directory when infinite sessions are
     * enabled.
     * &lt;p&gt;
     * The workspace directory contains checkpoints/, plan.md, and files/
     * subdirectories.
     *
     * @return the workspace path, or {@code null} if infinite sessions are disabled
     */
    public String getWorkspacePath() {
<span class="nc" id="L154">        return workspacePath;</span>
    }

    /**
     * Sets a custom error handler for exceptions thrown by event handlers.
     * &lt;p&gt;
     * When an event handler registered via {@link #on(Consumer)} or
     * {@link #on(Class, Consumer)} throws an exception during event dispatch, the
     * error handler is invoked with the event and exception. The error is always
     * logged at {@link Level#WARNING} regardless of whether a custom handler is
     * set.
     *
     * &lt;p&gt;
     * Whether dispatch continues or stops after an error is controlled by the
     * {@link EventErrorPolicy} set via {@link #setEventErrorPolicy}. The error
     * handler is always invoked regardless of the policy.
     *
     * &lt;p&gt;
     * If the error handler itself throws an exception, that exception is caught and
     * logged at {@link Level#SEVERE}, and dispatch is stopped regardless of the
     * configured policy.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * session.setEventErrorHandler((event, exception) -&gt; {
     * 	metrics.increment(&quot;handler.errors&quot;);
     * 	logger.error(&quot;Handler failed on {}: {}&quot;, event.getType(), exception.getMessage());
     * });
     * }&lt;/pre&gt;
     *
     * @param handler
     *            the error handler, or {@code null} to use only the default logging
     *            behavior
     * @see EventErrorHandler
     * @see #setEventErrorPolicy(EventErrorPolicy)
     * @since 1.0.8
     */
    public void setEventErrorHandler(EventErrorHandler handler) {
<span class="fc" id="L194">        this.eventErrorHandler = handler;</span>
<span class="fc" id="L195">    }</span>

    /**
     * Sets the error propagation policy for event dispatch.
     * &lt;p&gt;
     * Controls whether remaining event listeners continue to execute when a
     * preceding listener throws an exception. Errors are always logged at
     * {@link Level#WARNING} regardless of the policy.
     *
     * &lt;ul&gt;
     * &lt;li&gt;{@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS} (default) — log the
     * error and stop dispatch after the first error&lt;/li&gt;
     * &lt;li&gt;{@link EventErrorPolicy#SUPPRESS_AND_LOG_ERRORS} — log the error and
     * continue dispatching to all remaining listeners&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * The configured {@link EventErrorHandler} (if any) is always invoked
     * regardless of the policy.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * // Opt-in to suppress errors (continue dispatching despite errors)
     * session.setEventErrorPolicy(EventErrorPolicy.SUPPRESS_AND_LOG_ERRORS);
     * session.setEventErrorHandler((event, ex) -&gt; logger.error(&quot;Handler failed, continuing: {}&quot;, ex.getMessage(), ex));
     * }&lt;/pre&gt;
     *
     * @param policy
     *            the error policy (default is
     *            {@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS})
     * @see EventErrorPolicy
     * @see #setEventErrorHandler(EventErrorHandler)
     * @since 1.0.8
     */
    public void setEventErrorPolicy(EventErrorPolicy policy) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (policy == null) {</span>
<span class="nc" id="L233">            throw new NullPointerException(&quot;policy must not be null&quot;);</span>
        }
<span class="fc" id="L235">        this.eventErrorPolicy = policy;</span>
<span class="fc" id="L236">    }</span>

    /**
     * Sends a simple text message to the Copilot session.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code send(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the message ID assigned by the server
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;String&gt; send(String prompt) {
<span class="nc" id="L250">        return send(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a simple text message and waits until the session becomes idle.
     * &lt;p&gt;
     * This is a convenience method equivalent to
     * {@code sendAndWait(new MessageOptions().setPrompt(prompt))}.
     *
     * @param prompt
     *            the message text to send
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @see #sendAndWait(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(String prompt) {
<span class="nc" id="L266">        return sendAndWait(new MessageOptions().setPrompt(prompt));</span>
    }

    /**
     * Sends a message to the Copilot session.
     * &lt;p&gt;
     * This method sends a message asynchronously and returns immediately. Use
     * {@link #sendAndWait(MessageOptions)} to wait for the response.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the message ID assigned by the server
     * @see #sendAndWait(MessageOptions)
     * @see #send(String)
     */
    public CompletableFuture&lt;String&gt; send(MessageOptions options) {
<span class="fc" id="L282">        var request = new SendMessageRequest();</span>
<span class="fc" id="L283">        request.setSessionId(sessionId);</span>
<span class="fc" id="L284">        request.setPrompt(options.getPrompt());</span>
<span class="fc" id="L285">        request.setAttachments(options.getAttachments());</span>
<span class="fc" id="L286">        request.setMode(options.getMode());</span>

<span class="fc" id="L288">        return rpc.invoke(&quot;session.send&quot;, request, SendMessageResponse.class)</span>
<span class="fc" id="L289">                .thenApply(SendMessageResponse::getMessageId);</span>
    }

    /**
     * Sends a message and waits until the session becomes idle.
     * &lt;p&gt;
     * This method blocks until the assistant finishes processing the message or
     * until the timeout expires. It's suitable for simple request/response
     * interactions where you don't need to process streaming events.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @param timeoutMs
     *            timeout in milliseconds (0 or negative for no timeout)
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received. The future
     *         completes exceptionally with a TimeoutException if the timeout
     *         expires.
     * @see #sendAndWait(MessageOptions)
     * @see #send(MessageOptions)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options, long timeoutMs) {
<span class="fc" id="L311">        var future = new CompletableFuture&lt;AssistantMessageEvent&gt;();</span>
<span class="fc" id="L312">        var lastAssistantMessage = new AtomicReference&lt;AssistantMessageEvent&gt;();</span>

<span class="fc" id="L314">        Consumer&lt;AbstractSessionEvent&gt; handler = evt -&gt; {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (evt instanceof AssistantMessageEvent msg) {</span>
<span class="fc" id="L316">                lastAssistantMessage.set(msg);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            } else if (evt instanceof SessionIdleEvent) {</span>
<span class="fc" id="L318">                future.complete(lastAssistantMessage.get());</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            } else if (evt instanceof SessionErrorEvent errorEvent) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                String message = errorEvent.getData() != null ? errorEvent.getData().getMessage() : &quot;session error&quot;;</span>
<span class="nc" id="L321">                future.completeExceptionally(new RuntimeException(&quot;Session error: &quot; + message));</span>
            }
<span class="fc" id="L323">        };</span>

<span class="fc" id="L325">        Closeable subscription = on(handler);</span>

<span class="fc" id="L327">        send(options).exceptionally(ex -&gt; {</span>
            try {
<span class="nc" id="L329">                subscription.close();</span>
<span class="nc" id="L330">            } catch (Exception e) {</span>
<span class="nc" id="L331">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="nc" id="L332">            }</span>
<span class="nc" id="L333">            future.completeExceptionally(ex);</span>
<span class="nc" id="L334">            return null;</span>
        });

        // Set up timeout with daemon thread so it doesn't prevent JVM exit
<span class="fc" id="L338">        var scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; {</span>
<span class="fc" id="L339">            var t = new Thread(r, &quot;sendAndWait-timeout&quot;);</span>
<span class="fc" id="L340">            t.setDaemon(true);</span>
<span class="fc" id="L341">            return t;</span>
        });
<span class="fc" id="L343">        scheduler.schedule(() -&gt; {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (!future.isDone()) {</span>
<span class="fc" id="L345">                future.completeExceptionally(new TimeoutException(&quot;sendAndWait timed out after &quot; + timeoutMs + &quot;ms&quot;));</span>
            }
<span class="fc" id="L347">            scheduler.shutdown();</span>
<span class="fc" id="L348">        }, timeoutMs, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L350">        return future.whenComplete((result, ex) -&gt; {</span>
            try {
<span class="fc" id="L352">                subscription.close();</span>
<span class="nc" id="L353">            } catch (IOException e) {</span>
<span class="nc" id="L354">                LOG.log(Level.SEVERE, &quot;Error closing subscription&quot;, e);</span>
<span class="fc" id="L355">            }</span>
<span class="fc" id="L356">            scheduler.shutdown();</span>
<span class="fc" id="L357">        });</span>
    }

    /**
     * Sends a message and waits until the session becomes idle with default 60
     * second timeout.
     *
     * @param options
     *            the message options containing the prompt and attachments
     * @return a future that resolves with the final assistant message event, or
     *         {@code null} if no assistant message was received
     * @see #sendAndWait(MessageOptions, long)
     */
    public CompletableFuture&lt;AssistantMessageEvent&gt; sendAndWait(MessageOptions options) {
<span class="fc" id="L371">        return sendAndWait(options, 60000);</span>
    }

    /**
     * Registers a callback for all session events.
     * &lt;p&gt;
     * The handler will be invoked for every event in this session, including
     * assistant messages, tool calls, and session state changes. For type-safe
     * handling of specific event types, prefer {@link #on(Class, Consumer)}
     * instead.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception handling:&lt;/b&gt; If a handler throws an exception, the error is
     * routed to the configured {@link EventErrorHandler} (if set). Whether
     * remaining handlers execute depends on the configured
     * {@link EventErrorPolicy}.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example:&lt;/b&gt;
     *
     * &lt;pre&gt;{@code
     * // Collect all events
     * var events = new ArrayList&lt;AbstractSessionEvent&gt;();
     * session.on(events::add);
     * }&lt;/pre&gt;
     *
     * @param handler
     *            a callback to be invoked when a session event occurs
     * @return a Closeable that, when closed, unsubscribes the handler
     * @see #on(Class, Consumer)
     * @see AbstractSessionEvent
     * @see #setEventErrorPolicy(EventErrorPolicy)
     */
    public Closeable on(Consumer&lt;AbstractSessionEvent&gt; handler) {
<span class="fc" id="L405">        eventHandlers.add(handler);</span>
<span class="fc" id="L406">        return () -&gt; eventHandlers.remove(handler);</span>
    }

    /**
     * Registers an event handler for a specific event type.
     * &lt;p&gt;
     * This provides a type-safe way to handle specific events without needing
     * {@code instanceof} checks. The handler will only be called for events
     * matching the specified type.
     *
     * &lt;p&gt;
     * &lt;b&gt;Exception handling:&lt;/b&gt; If a handler throws an exception, the error is
     * routed to the configured {@link EventErrorHandler} (if set). Whether
     * remaining handlers execute depends on the configured
     * {@link EventErrorPolicy}.
     *
     * &lt;p&gt;
     * &lt;b&gt;Example Usage&lt;/b&gt;
     * &lt;/p&gt;
     *
     * &lt;pre&gt;{@code
     * // Handle assistant messages
     * session.on(AssistantMessageEvent.class, msg -&gt; {
     * 	System.out.println(msg.getData().getContent());
     * });
     *
     * // Handle session idle
     * session.on(SessionIdleEvent.class, idle -&gt; {
     * 	done.complete(null);
     * });
     *
     * // Handle streaming deltas
     * session.on(AssistantMessageDeltaEvent.class, delta -&gt; {
     * 	System.out.print(delta.getData().getDeltaContent());
     * });
     * }&lt;/pre&gt;
     *
     * @param &lt;T&gt;
     *            the event type
     * @param eventType
     *            the class of the event to listen for
     * @param handler
     *            a callback invoked when events of this type occur
     * @return a Closeable that unsubscribes the handler when closed
     * @see #on(Consumer)
     * @see AbstractSessionEvent
     */
    public &lt;T extends AbstractSessionEvent&gt; Closeable on(Class&lt;T&gt; eventType, Consumer&lt;T&gt; handler) {
<span class="fc" id="L454">        Consumer&lt;AbstractSessionEvent&gt; wrapper = event -&gt; {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (eventType.isInstance(event)) {</span>
<span class="fc" id="L456">                handler.accept(eventType.cast(event));</span>
            }
<span class="fc" id="L458">        };</span>
<span class="fc" id="L459">        eventHandlers.add(wrapper);</span>
<span class="fc" id="L460">        return () -&gt; eventHandlers.remove(wrapper);</span>
    }

    /**
     * Dispatches an event to all registered handlers.
     * &lt;p&gt;
     * This is called internally when events are received from the server. Each
     * handler is invoked in its own try/catch block. Errors are always logged at
     * {@link Level#WARNING}. Whether dispatch continues after a handler error
     * depends on the configured {@link EventErrorPolicy}:
     * &lt;ul&gt;
     * &lt;li&gt;{@link EventErrorPolicy#PROPAGATE_AND_LOG_ERRORS} (default) — dispatch
     * stops after the first error&lt;/li&gt;
     * &lt;li&gt;{@link EventErrorPolicy#SUPPRESS_AND_LOG_ERRORS} — remaining handlers
     * still execute&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The configured {@link EventErrorHandler} is always invoked (if set),
     * regardless of the policy. If the error handler itself throws, dispatch stops
     * regardless of policy and the error is logged at {@link Level#SEVERE}.
     *
     * @param event
     *            the event to dispatch
     * @see #setEventErrorHandler(EventErrorHandler)
     * @see #setEventErrorPolicy(EventErrorPolicy)
     */
    void dispatchEvent(AbstractSessionEvent event) {
<span class="fc bfc" id="L487" title="All 2 branches covered.">        for (Consumer&lt;AbstractSessionEvent&gt; handler : eventHandlers) {</span>
            try {
<span class="fc" id="L489">                handler.accept(event);</span>
<span class="fc" id="L490">            } catch (Exception e) {</span>
<span class="fc" id="L491">                LOG.log(Level.WARNING, &quot;Error in event handler&quot;, e);</span>
<span class="fc" id="L492">                EventErrorHandler errorHandler = this.eventErrorHandler;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">                if (errorHandler != null) {</span>
                    try {
<span class="fc" id="L495">                        errorHandler.handleError(event, e);</span>
<span class="fc" id="L496">                    } catch (Exception errorHandlerException) {</span>
<span class="fc" id="L497">                        LOG.log(Level.SEVERE, &quot;Error in event error handler&quot;, errorHandlerException);</span>
<span class="fc" id="L498">                        break; // error handler itself failed — stop regardless of policy</span>
<span class="fc" id="L499">                    }</span>
                }
<span class="fc bfc" id="L501" title="All 2 branches covered.">                if (eventErrorPolicy == EventErrorPolicy.PROPAGATE_AND_LOG_ERRORS) {</span>
<span class="fc" id="L502">                    break;</span>
                }
<span class="fc" id="L504">            }</span>
<span class="fc" id="L505">        }</span>
<span class="fc" id="L506">    }</span>

    /**
     * Registers custom tool handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with tools.
     *
     * @param tools
     *            the list of tool definitions with handlers
     */
    void registerTools(List&lt;ToolDefinition&gt; tools) {
<span class="fc" id="L517">        toolHandlers.clear();</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        if (tools != null) {</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            for (ToolDefinition tool : tools) {</span>
<span class="fc" id="L520">                toolHandlers.put(tool.getName(), tool);</span>
<span class="fc" id="L521">            }</span>
        }
<span class="fc" id="L523">    }</span>

    /**
     * Retrieves a registered tool by name.
     *
     * @param name
     *            the tool name
     * @return the tool definition, or {@code null} if not found
     */
    ToolDefinition getTool(String name) {
<span class="fc" id="L533">        return toolHandlers.get(name);</span>
    }

    /**
     * Registers a handler for permission requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with permission
     * handling.
     *
     * @param handler
     *            the permission handler
     */
    void registerPermissionHandler(PermissionHandler handler) {
<span class="fc" id="L546">        permissionHandler.set(handler);</span>
<span class="fc" id="L547">    }</span>

    /**
     * Handles a permission request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests permission for an operation.
     *
     * @param permissionRequestData
     *            the JSON data for the permission request
     * @return a future that resolves with the permission result
     */
    CompletableFuture&lt;PermissionRequestResult&gt; handlePermissionRequest(JsonNode permissionRequestData) {
<span class="fc" id="L559">        PermissionHandler handler = permissionHandler.get();</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L561">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="nc" id="L562">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L563">            return CompletableFuture.completedFuture(result);</span>
        }

        try {
<span class="fc" id="L567">            PermissionRequest request = MAPPER.treeToValue(permissionRequestData, PermissionRequest.class);</span>
<span class="fc" id="L568">            var invocation = new PermissionInvocation();</span>
<span class="fc" id="L569">            invocation.setSessionId(sessionId);</span>
<span class="fc" id="L570">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="nc" id="L571">                LOG.log(Level.SEVERE, &quot;Permission handler threw an exception&quot;, ex);</span>
<span class="nc" id="L572">                PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="nc" id="L573">                result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L574">                return result;</span>
            });
<span class="fc" id="L576">        } catch (Exception e) {</span>
<span class="fc" id="L577">            LOG.log(Level.SEVERE, &quot;Failed to process permission request&quot;, e);</span>
<span class="fc" id="L578">            PermissionRequestResult result = new PermissionRequestResult();</span>
<span class="fc" id="L579">            result.setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="fc" id="L580">            return CompletableFuture.completedFuture(result);</span>
        }
    }

    /**
     * Registers a handler for user input requests.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with user input
     * handling.
     *
     * @param handler
     *            the user input handler
     */
    void registerUserInputHandler(UserInputHandler handler) {
<span class="fc" id="L594">        userInputHandler.set(handler);</span>
<span class="fc" id="L595">    }</span>

    /**
     * Handles a user input request from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server requests user input.
     *
     * @param request
     *            the user input request
     * @return a future that resolves with the user input response
     */
    CompletableFuture&lt;UserInputResponse&gt; handleUserInputRequest(UserInputRequest request) {
<span class="fc" id="L607">        UserInputHandler handler = userInputHandler.get();</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L609">            return CompletableFuture.failedFuture(new IllegalStateException(&quot;No user input handler registered&quot;));</span>
        }

        try {
<span class="fc" id="L613">            var invocation = new UserInputInvocation().setSessionId(sessionId);</span>
<span class="fc" id="L614">            return handler.handle(request, invocation).exceptionally(ex -&gt; {</span>
<span class="nc" id="L615">                LOG.log(Level.SEVERE, &quot;User input handler threw an exception&quot;, ex);</span>
<span class="nc" id="L616">                throw new RuntimeException(&quot;User input handler error&quot;, ex);</span>
            });
<span class="nc" id="L618">        } catch (Exception e) {</span>
<span class="nc" id="L619">            LOG.log(Level.SEVERE, &quot;Failed to process user input request&quot;, e);</span>
<span class="nc" id="L620">            return CompletableFuture.failedFuture(e);</span>
        }
    }

    /**
     * Registers hook handlers for this session.
     * &lt;p&gt;
     * Called internally when creating or resuming a session with hooks.
     *
     * @param hooks
     *            the hooks configuration
     */
    void registerHooks(SessionHooks hooks) {
<span class="fc" id="L633">        hooksHandler.set(hooks);</span>
<span class="fc" id="L634">    }</span>

    /**
     * Handles a hook invocation from the Copilot CLI.
     * &lt;p&gt;
     * Called internally when the server invokes a hook.
     *
     * @param hookType
     *            the type of hook to invoke
     * @param input
     *            the hook input data
     * @return a future that resolves with the hook output
     */
    CompletableFuture&lt;Object&gt; handleHooksInvoke(String hookType, JsonNode input) {
<span class="fc" id="L648">        SessionHooks hooks = hooksHandler.get();</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (hooks == null) {</span>
<span class="nc" id="L650">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L653">        var invocation = new HookInvocation().setSessionId(sessionId);</span>

        try {
<span class="pc bpc" id="L656" title="1 of 6 branches missed.">            switch (hookType) {</span>
                case &quot;preToolUse&quot; :
<span class="fc bfc" id="L658" title="All 2 branches covered.">                    if (hooks.getOnPreToolUse() != null) {</span>
<span class="fc" id="L659">                        PreToolUseHookInput preInput = MAPPER.treeToValue(input, PreToolUseHookInput.class);</span>
<span class="fc" id="L660">                        return hooks.getOnPreToolUse().handle(preInput, invocation)</span>
<span class="fc" id="L661">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;postToolUse&quot; :
<span class="fc bfc" id="L665" title="All 2 branches covered.">                    if (hooks.getOnPostToolUse() != null) {</span>
<span class="fc" id="L666">                        PostToolUseHookInput postInput = MAPPER.treeToValue(input, PostToolUseHookInput.class);</span>
<span class="fc" id="L667">                        return hooks.getOnPostToolUse().handle(postInput, invocation)</span>
<span class="fc" id="L668">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;userPromptSubmitted&quot; :
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">                    if (hooks.getOnUserPromptSubmitted() != null) {</span>
<span class="nc" id="L673">                        UserPromptSubmittedHookInput promptInput = MAPPER.treeToValue(input,</span>
                                UserPromptSubmittedHookInput.class);
<span class="nc" id="L675">                        return hooks.getOnUserPromptSubmitted().handle(promptInput, invocation)</span>
<span class="nc" id="L676">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionStart&quot; :
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                    if (hooks.getOnSessionStart() != null) {</span>
<span class="nc" id="L681">                        SessionStartHookInput startInput = MAPPER.treeToValue(input, SessionStartHookInput.class);</span>
<span class="nc" id="L682">                        return hooks.getOnSessionStart().handle(startInput, invocation)</span>
<span class="nc" id="L683">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                case &quot;sessionEnd&quot; :
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">                    if (hooks.getOnSessionEnd() != null) {</span>
<span class="nc" id="L688">                        SessionEndHookInput endInput = MAPPER.treeToValue(input, SessionEndHookInput.class);</span>
<span class="nc" id="L689">                        return hooks.getOnSessionEnd().handle(endInput, invocation)</span>
<span class="nc" id="L690">                                .thenApply(output -&gt; (Object) output);</span>
                    }
                    break;
                default :
<span class="nc" id="L694">                    LOG.fine(&quot;Unhandled hook type: &quot; + hookType);</span>
            }
<span class="nc" id="L696">        } catch (Exception e) {</span>
<span class="nc" id="L697">            LOG.log(Level.SEVERE, &quot;Failed to process hook invocation&quot;, e);</span>
<span class="nc" id="L698">            return CompletableFuture.failedFuture(e);</span>
<span class="fc" id="L699">        }</span>

<span class="fc" id="L701">        return CompletableFuture.completedFuture(null);</span>
    }

    /**
     * Gets the complete list of messages and events in the session.
     * &lt;p&gt;
     * This retrieves the full conversation history, including all user messages,
     * assistant responses, tool invocations, and other session events.
     *
     * @return a future that resolves with a list of all session events
     * @see AbstractSessionEvent
     */
    public CompletableFuture&lt;List&lt;AbstractSessionEvent&gt;&gt; getMessages() {
<span class="fc" id="L714">        return rpc.invoke(&quot;session.getMessages&quot;, Map.of(&quot;sessionId&quot;, sessionId), GetMessagesResponse.class)</span>
<span class="fc" id="L715">                .thenApply(response -&gt; {</span>
<span class="fc" id="L716">                    var events = new ArrayList&lt;AbstractSessionEvent&gt;();</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                    if (response.getEvents() != null) {</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">                        for (JsonNode eventNode : response.getEvents()) {</span>
                            try {
<span class="fc" id="L720">                                AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">                                if (event != null) {</span>
<span class="fc" id="L722">                                    events.add(event);</span>
                                }
<span class="nc" id="L724">                            } catch (Exception e) {</span>
<span class="nc" id="L725">                                LOG.log(Level.WARNING, &quot;Failed to parse event&quot;, e);</span>
<span class="fc" id="L726">                            }</span>
<span class="fc" id="L727">                        }</span>
                    }
<span class="fc" id="L729">                    return events;</span>
                });
    }

    /**
     * Aborts the currently processing message in this session.
     * &lt;p&gt;
     * Use this to cancel a long-running operation or stop the assistant from
     * continuing to generate a response.
     *
     * @return a future that completes when the abort is acknowledged
     */
    public CompletableFuture&lt;Void&gt; abort() {
<span class="fc" id="L742">        return rpc.invoke(&quot;session.abort&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class);</span>
    }

    /**
     * Disposes the session and releases all associated resources.
     * &lt;p&gt;
     * This destroys the session on the server, clears all event handlers, and
     * releases tool and permission handlers. After calling this method, the session
     * cannot be used again.
     */
    @Override
    public void close() {
        try {
<span class="fc" id="L755">            rpc.invoke(&quot;session.destroy&quot;, Map.of(&quot;sessionId&quot;, sessionId), Void.class).get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L756">        } catch (Exception e) {</span>
<span class="nc" id="L757">            LOG.log(Level.FINE, &quot;Error destroying session&quot;, e);</span>
<span class="fc" id="L758">        }</span>

<span class="fc" id="L760">        eventHandlers.clear();</span>
<span class="fc" id="L761">        toolHandlers.clear();</span>
<span class="fc" id="L762">        permissionHandler.set(null);</span>
<span class="fc" id="L763">        userInputHandler.set(null);</span>
<span class="fc" id="L764">        hooksHandler.set(null);</span>
<span class="fc" id="L765">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>