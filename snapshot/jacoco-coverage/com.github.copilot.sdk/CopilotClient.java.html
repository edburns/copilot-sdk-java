<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CopilotClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub Copilot Community SDK :: Java</a> &gt; <a href="index.source.html" class="el_package">com.github.copilot.sdk</a> &gt; <span class="el_source">CopilotClient.java</span></div><h1>CopilotClient.java</h1><pre class="source lang-java linenums">/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

package com.github.copilot.sdk;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.SessionEventParser;
import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.CreateSessionRequest;
import com.github.copilot.sdk.json.CreateSessionResponse;
import com.github.copilot.sdk.json.DeleteSessionResponse;
import com.github.copilot.sdk.json.GetAuthStatusResponse;
import com.github.copilot.sdk.json.GetLastSessionIdResponse;
import com.github.copilot.sdk.json.GetModelsResponse;
import com.github.copilot.sdk.json.GetStatusResponse;
import com.github.copilot.sdk.json.ListSessionsResponse;
import com.github.copilot.sdk.json.ModelInfo;
import com.github.copilot.sdk.json.PermissionRequestResult;
import com.github.copilot.sdk.json.PingResponse;
import com.github.copilot.sdk.json.ResumeSessionConfig;
import com.github.copilot.sdk.json.ResumeSessionRequest;
import com.github.copilot.sdk.json.ResumeSessionResponse;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SessionMetadata;
import com.github.copilot.sdk.json.ToolDef;
import com.github.copilot.sdk.json.ToolDefinition;
import com.github.copilot.sdk.json.ToolInvocation;
import com.github.copilot.sdk.json.ToolResultObject;

/**
 * Provides a client for interacting with the Copilot CLI server.
 * &lt;p&gt;
 * The CopilotClient manages the connection to the Copilot CLI server and
 * provides methods to create and manage conversation sessions. It can either
 * spawn a CLI server process or connect to an existing server.
 * &lt;p&gt;
 * Example usage:
 *
 * &lt;pre&gt;{@code
 * try (CopilotClient client = new CopilotClient()) {
 * 	client.start().get();
 *
 * 	CopilotSession session = client.createSession(new SessionConfig().setModel(&quot;gpt-5&quot;)).get();
 *
 * 	session.on(evt -&gt; {
 * 		if (evt instanceof AssistantMessageEvent msg) {
 * 			System.out.println(msg.getData().getContent());
 * 		}
 * 	});
 *
 * 	session.send(new MessageOptions().setPrompt(&quot;Hello!&quot;)).get();
 * }
 * }&lt;/pre&gt;
 *
 * @since 1.0.0
 */
public class CopilotClient implements AutoCloseable {

<span class="fc" id="L83">    private static final Logger LOG = Logger.getLogger(CopilotClient.class.getName());</span>
<span class="fc" id="L84">    private static final ObjectMapper MAPPER = JsonRpcClient.getObjectMapper();</span>

    private final CopilotClientOptions options;
<span class="fc" id="L87">    private final Map&lt;String, CopilotSession&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span>
    private volatile CompletableFuture&lt;Connection&gt; connectionFuture;
<span class="fc" id="L89">    private volatile boolean disposed = false;</span>
    private final String optionsHost;
    private final Integer optionsPort;
    private volatile List&lt;ModelInfo&gt; modelsCache;
<span class="fc" id="L93">    private final Object modelsCacheLock = new Object();</span>
<span class="fc" id="L94">    private final List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; lifecycleHandlers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L95">    private final Map&lt;String, List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt;&gt; typedLifecycleHandlers = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L96">    private final Object lifecycleHandlersLock = new Object();</span>

    /**
     * Creates a new CopilotClient with default options.
     */
    public CopilotClient() {
<span class="fc" id="L102">        this(new CopilotClientOptions());</span>
<span class="fc" id="L103">    }</span>

    /**
     * Creates a new CopilotClient with the specified options.
     *
     * @param options
     *            Options for creating the client
     * @throws IllegalArgumentException
     *             if mutually exclusive options are provided
     */
<span class="fc" id="L113">    public CopilotClient(CopilotClientOptions options) {</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        this.options = options != null ? options : new CopilotClientOptions();</span>

        // Validate mutually exclusive options
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="fc bfc" id="L118" title="All 4 branches covered.">                &amp;&amp; (this.options.isUseStdio() || this.options.getCliPath() != null)) {</span>
<span class="fc" id="L119">            throw new IllegalArgumentException(&quot;CliUrl is mutually exclusive with UseStdio and CliPath&quot;);</span>
        }

        // Validate auth options with external server
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()</span>
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">                &amp;&amp; (this.options.getGithubToken() != null || this.options.getUseLoggedInUser() != null)) {</span>
<span class="fc" id="L125">            throw new IllegalArgumentException(</span>
                    &quot;GithubToken and UseLoggedInUser cannot be used with CliUrl (external server manages its own auth)&quot;);
        }

        // Parse CliUrl if provided
<span class="pc bpc" id="L130" title="3 of 4 branches missed.">        if (this.options.getCliUrl() != null &amp;&amp; !this.options.getCliUrl().isEmpty()) {</span>
<span class="nc" id="L131">            URI uri = parseCliUrl(this.options.getCliUrl());</span>
<span class="nc" id="L132">            this.optionsHost = uri.getHost();</span>
<span class="nc" id="L133">            this.optionsPort = uri.getPort();</span>
<span class="nc" id="L134">        } else {</span>
<span class="fc" id="L135">            this.optionsHost = null;</span>
<span class="fc" id="L136">            this.optionsPort = null;</span>
        }
<span class="fc" id="L138">    }</span>

    private static URI parseCliUrl(String url) {
        // If it's just a port number, treat as localhost
        try {
<span class="nc" id="L143">            int port = Integer.parseInt(url);</span>
<span class="nc" id="L144">            return URI.create(&quot;http://localhost:&quot; + port);</span>
<span class="nc" id="L145">        } catch (NumberFormatException e) {</span>
            // Not a port number, continue
        }

        // Add scheme if missing
<span class="nc bnc" id="L150" title="All 4 branches missed.">        if (!url.toLowerCase().startsWith(&quot;http://&quot;) &amp;&amp; !url.toLowerCase().startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L151">            url = &quot;https://&quot; + url;</span>
        }

<span class="nc" id="L154">        return URI.create(url);</span>
    }

    /**
     * Starts the Copilot client and connects to the server.
     *
     * @return A future that completes when the connection is established
     */
    public CompletableFuture&lt;Void&gt; start() {
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (connectionFuture == null) {</span>
<span class="fc" id="L164">            synchronized (this) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                if (connectionFuture == null) {</span>
<span class="fc" id="L166">                    connectionFuture = startCore();</span>
                }
<span class="fc" id="L168">            }</span>
        }
<span class="fc" id="L170">        return connectionFuture.thenApply(c -&gt; null);</span>
    }

    private CompletableFuture&lt;Connection&gt; startCore() {
<span class="fc" id="L174">        LOG.fine(&quot;Starting Copilot client&quot;);</span>

<span class="fc" id="L176">        return CompletableFuture.supplyAsync(() -&gt; {</span>
            try {
                Connection connection;

<span class="pc bpc" id="L180" title="3 of 4 branches missed.">                if (optionsHost != null &amp;&amp; optionsPort != null) {</span>
                    // External server (TCP)
<span class="nc" id="L182">                    connection = connectToServer(null, optionsHost, optionsPort);</span>
                } else {
                    // Child process (stdio or TCP)
<span class="fc" id="L185">                    ProcessInfo processInfo = startCliServer();</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">                    connection = connectToServer(processInfo.process, processInfo.port != null ? &quot;localhost&quot; : null,</span>
                            processInfo.port);
                }

                // Register handlers for server-to-client calls
<span class="fc" id="L191">                registerRpcHandlers(connection.rpc);</span>

                // Verify protocol version
<span class="fc" id="L194">                verifyProtocolVersion(connection);</span>

<span class="fc" id="L196">                LOG.info(&quot;Copilot client connected&quot;);</span>
<span class="fc" id="L197">                return connection;</span>
<span class="nc" id="L198">            } catch (Exception e) {</span>
<span class="nc" id="L199">                throw new CompletionException(e);</span>
            }
        });
    }

    private void registerRpcHandlers(JsonRpcClient rpc) {
        // Handle session events
<span class="fc" id="L206">        rpc.registerMethodHandler(&quot;session.event&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="fc" id="L208">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L209">                JsonNode eventNode = params.get(&quot;event&quot;);</span>
<span class="fc" id="L210">                LOG.fine(&quot;Received session.event: &quot; + eventNode);</span>

<span class="fc" id="L212">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">                if (session != null &amp;&amp; eventNode != null) {</span>
<span class="fc" id="L214">                    AbstractSessionEvent event = SessionEventParser.parse(eventNode.toString());</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">                    if (event != null) {</span>
<span class="fc" id="L216">                        session.dispatchEvent(event);</span>
                    }
                }
<span class="nc" id="L219">            } catch (Exception e) {</span>
<span class="nc" id="L220">                LOG.log(Level.SEVERE, &quot;Error handling session event&quot;, e);</span>
<span class="fc" id="L221">            }</span>
<span class="fc" id="L222">        });</span>

        // Handle session lifecycle events
<span class="fc" id="L225">        rpc.registerMethodHandler(&quot;session.lifecycle&quot;, (requestId, params) -&gt; {</span>
            try {
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                String type = params.has(&quot;type&quot;) ? params.get(&quot;type&quot;).asText() : &quot;&quot;;</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                String sessionId = params.has(&quot;sessionId&quot;) ? params.get(&quot;sessionId&quot;).asText() : &quot;&quot;;</span>

<span class="fc" id="L230">                com.github.copilot.sdk.json.SessionLifecycleEvent event = new com.github.copilot.sdk.json.SessionLifecycleEvent();</span>
<span class="fc" id="L231">                event.setType(type);</span>
<span class="fc" id="L232">                event.setSessionId(sessionId);</span>

<span class="pc bpc" id="L234" title="1 of 4 branches missed.">                if (params.has(&quot;metadata&quot;) &amp;&amp; !params.get(&quot;metadata&quot;).isNull()) {</span>
<span class="fc" id="L235">                    com.github.copilot.sdk.json.SessionLifecycleEventMetadata metadata = MAPPER.treeToValue(</span>
<span class="fc" id="L236">                            params.get(&quot;metadata&quot;), com.github.copilot.sdk.json.SessionLifecycleEventMetadata.class);</span>
<span class="fc" id="L237">                    event.setMetadata(metadata);</span>
                }

<span class="fc" id="L240">                dispatchLifecycleEvent(event);</span>
<span class="nc" id="L241">            } catch (Exception e) {</span>
<span class="nc" id="L242">                LOG.log(Level.SEVERE, &quot;Error handling session lifecycle event&quot;, e);</span>
<span class="fc" id="L243">            }</span>
<span class="fc" id="L244">        });</span>

        // Handle tool calls
<span class="fc" id="L247">        rpc.registerMethodHandler(&quot;tool.call&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L248">            handleToolCall(rpc, requestId, params);</span>
<span class="fc" id="L249">        });</span>

        // Handle permission requests
<span class="fc" id="L252">        rpc.registerMethodHandler(&quot;permission.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L253">            handlePermissionRequest(rpc, requestId, params);</span>
<span class="fc" id="L254">        });</span>

        // Handle user input requests
<span class="fc" id="L257">        rpc.registerMethodHandler(&quot;userInput.request&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L258">            handleUserInputRequest(rpc, requestId, params);</span>
<span class="fc" id="L259">        });</span>

        // Handle hooks invocations
<span class="fc" id="L262">        rpc.registerMethodHandler(&quot;hooks.invoke&quot;, (requestId, params) -&gt; {</span>
<span class="fc" id="L263">            handleHooksInvoke(rpc, requestId, params);</span>
<span class="fc" id="L264">        });</span>
<span class="fc" id="L265">    }</span>

    private void handleToolCall(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L268">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L270">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L271">                String toolCallId = params.get(&quot;toolCallId&quot;).asText();</span>
<span class="fc" id="L272">                String toolName = params.get(&quot;toolName&quot;).asText();</span>
<span class="fc" id="L273">                JsonNode arguments = params.get(&quot;arguments&quot;);</span>

<span class="fc" id="L275">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L277">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L278">                    return;</span>
                }

<span class="fc" id="L281">                ToolDefinition tool = session.getTool(toolName);</span>
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">                if (tool == null || tool.getHandler() == null) {</span>
<span class="nc" id="L283">                    ToolResultObject result = new ToolResultObject()</span>
<span class="nc" id="L284">                            .setTextResultForLlm(&quot;Tool '&quot; + toolName + &quot;' is not supported.&quot;).setResultType(&quot;failure&quot;)</span>
<span class="nc" id="L285">                            .setError(&quot;tool '&quot; + toolName + &quot;' not supported&quot;);</span>
<span class="nc" id="L286">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L287">                    return;</span>
                }

<span class="fc" id="L290">                ToolInvocation invocation = new ToolInvocation().setSessionId(sessionId).setToolCallId(toolCallId)</span>
<span class="fc" id="L291">                        .setToolName(toolName).setArguments(arguments);</span>

<span class="fc" id="L293">                tool.getHandler().invoke(invocation).thenAccept(result -&gt; {</span>
                    try {
                        ToolResultObject toolResult;
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                        if (result instanceof ToolResultObject tr) {</span>
<span class="nc" id="L297">                            toolResult = tr;</span>
                        } else {
<span class="fc" id="L299">                            toolResult = new ToolResultObject().setResultType(&quot;success&quot;).setTextResultForLlm(</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                                    result instanceof String s ? s : MAPPER.writeValueAsString(result));</span>
                        }
<span class="fc" id="L302">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, toolResult));</span>
<span class="nc" id="L303">                    } catch (Exception e) {</span>
<span class="nc" id="L304">                        LOG.log(Level.SEVERE, &quot;Error sending tool result&quot;, e);</span>
<span class="fc" id="L305">                    }</span>
<span class="fc" id="L306">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L308">                        ToolResultObject result = new ToolResultObject()</span>
<span class="fc" id="L309">                                .setTextResultForLlm(</span>
                                        &quot;Invoking this tool produced an error. Detailed information is not available.&quot;)
<span class="fc" id="L311">                                .setResultType(&quot;failure&quot;).setError(ex.getMessage());</span>
<span class="fc" id="L312">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L313">                    } catch (Exception e) {</span>
<span class="nc" id="L314">                        LOG.log(Level.SEVERE, &quot;Error sending tool error&quot;, e);</span>
<span class="fc" id="L315">                    }</span>
<span class="fc" id="L316">                    return null;</span>
                });
<span class="nc" id="L318">            } catch (Exception e) {</span>
<span class="nc" id="L319">                LOG.log(Level.SEVERE, &quot;Error handling tool call&quot;, e);</span>
                try {
<span class="nc" id="L321">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32603, e.getMessage());</span>
<span class="nc" id="L322">                } catch (IOException ioe) {</span>
<span class="nc" id="L323">                    LOG.log(Level.SEVERE, &quot;Failed to send error response&quot;, ioe);</span>
<span class="nc" id="L324">                }</span>
<span class="fc" id="L325">            }</span>
<span class="fc" id="L326">        });</span>
<span class="fc" id="L327">    }</span>

    private void handlePermissionRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L330">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L332">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L333">                JsonNode permissionRequest = params.get(&quot;permissionRequest&quot;);</span>

<span class="fc" id="L335">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L337">                    PermissionRequestResult result = new PermissionRequestResult()</span>
<span class="nc" id="L338">                            .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L339">                    rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L340">                    return;</span>
                }

<span class="fc" id="L343">                session.handlePermissionRequest(permissionRequest).thenAccept(result -&gt; {</span>
                    try {
<span class="fc" id="L345">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L346">                    } catch (IOException e) {</span>
<span class="nc" id="L347">                        LOG.log(Level.SEVERE, &quot;Error sending permission result&quot;, e);</span>
<span class="fc" id="L348">                    }</span>
<span class="fc" id="L349">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="nc" id="L351">                        PermissionRequestResult result = new PermissionRequestResult()</span>
<span class="nc" id="L352">                                .setKind(&quot;denied-no-approval-rule-and-could-not-request-from-user&quot;);</span>
<span class="nc" id="L353">                        rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;result&quot;, result));</span>
<span class="nc" id="L354">                    } catch (IOException e) {</span>
<span class="nc" id="L355">                        LOG.log(Level.SEVERE, &quot;Error sending permission denied&quot;, e);</span>
<span class="nc" id="L356">                    }</span>
<span class="nc" id="L357">                    return null;</span>
                });
<span class="nc" id="L359">            } catch (Exception e) {</span>
<span class="nc" id="L360">                LOG.log(Level.SEVERE, &quot;Error handling permission request&quot;, e);</span>
<span class="fc" id="L361">            }</span>
<span class="fc" id="L362">        });</span>
<span class="fc" id="L363">    }</span>

    private void handleUserInputRequest(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L366">        LOG.fine(&quot;Received userInput.request: &quot; + params);</span>
<span class="fc" id="L367">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L369">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L370">                String question = params.get(&quot;question&quot;).asText();</span>
<span class="fc" id="L371">                LOG.fine(&quot;Processing userInput for session &quot; + sessionId + &quot;, question: &quot; + question);</span>
<span class="fc" id="L372">                JsonNode choicesNode = params.get(&quot;choices&quot;);</span>
<span class="fc" id="L373">                JsonNode allowFreeformNode = params.get(&quot;allowFreeform&quot;);</span>

<span class="fc" id="L375">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">                LOG.fine(&quot;Found session: &quot; + (session != null));</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L378">                    LOG.fine(&quot;Session not found, sending error&quot;);</span>
<span class="nc" id="L379">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L380">                    return;</span>
                }

<span class="fc" id="L383">                com.github.copilot.sdk.json.UserInputRequest request = new com.github.copilot.sdk.json.UserInputRequest()</span>
<span class="fc" id="L384">                        .setQuestion(question);</span>
<span class="pc bpc" id="L385" title="1 of 4 branches missed.">                if (choicesNode != null &amp;&amp; choicesNode.isArray()) {</span>
<span class="fc" id="L386">                    List&lt;String&gt; choices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                    for (JsonNode choice : choicesNode) {</span>
<span class="fc" id="L388">                        choices.add(choice.asText());</span>
<span class="fc" id="L389">                    }</span>
<span class="fc" id="L390">                    request.setChoices(choices);</span>
                }
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">                if (allowFreeformNode != null) {</span>
<span class="fc" id="L393">                    request.setAllowFreeform(allowFreeformNode.asBoolean());</span>
                }

<span class="fc" id="L396">                session.handleUserInputRequest(request).thenAccept(response -&gt; {</span>
                    try {
                        // Ensure answer is never null - CLI requires a non-null string
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                        String answer = response.getAnswer() != null ? response.getAnswer() : &quot;&quot;;</span>
<span class="fc" id="L400">                        LOG.fine(&quot;Sending userInput response: answer=&quot; + answer + &quot;, wasFreeform=&quot;</span>
<span class="fc" id="L401">                                + response.isWasFreeform());</span>
<span class="fc" id="L402">                        rpc.sendResponse(Long.parseLong(requestId),</span>
<span class="fc" id="L403">                                Map.of(&quot;answer&quot;, answer, &quot;wasFreeform&quot;, response.isWasFreeform()));</span>
<span class="nc" id="L404">                    } catch (IOException e) {</span>
<span class="nc" id="L405">                        LOG.log(Level.SEVERE, &quot;Error sending user input response&quot;, e);</span>
<span class="fc" id="L406">                    }</span>
<span class="fc" id="L407">                }).exceptionally(ex -&gt; {</span>
<span class="nc" id="L408">                    LOG.log(Level.WARNING, &quot;User input handler exception&quot;, ex);</span>
                    try {
<span class="nc" id="L410">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="nc" id="L411">                                &quot;User input handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L412">                    } catch (IOException e) {</span>
<span class="nc" id="L413">                        LOG.log(Level.SEVERE, &quot;Error sending user input error&quot;, e);</span>
<span class="nc" id="L414">                    }</span>
<span class="nc" id="L415">                    return null;</span>
                });
<span class="nc" id="L417">            } catch (Exception e) {</span>
<span class="nc" id="L418">                LOG.log(Level.SEVERE, &quot;Error handling user input request&quot;, e);</span>
<span class="fc" id="L419">            }</span>
<span class="fc" id="L420">        });</span>
<span class="fc" id="L421">    }</span>

    private void handleHooksInvoke(JsonRpcClient rpc, String requestId, JsonNode params) {
<span class="fc" id="L424">        CompletableFuture.runAsync(() -&gt; {</span>
            try {
<span class="fc" id="L426">                String sessionId = params.get(&quot;sessionId&quot;).asText();</span>
<span class="fc" id="L427">                String hookType = params.get(&quot;hookType&quot;).asText();</span>
<span class="fc" id="L428">                JsonNode input = params.get(&quot;input&quot;);</span>

<span class="fc" id="L430">                CopilotSession session = sessions.get(sessionId);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L432">                    rpc.sendErrorResponse(Long.parseLong(requestId), -32602, &quot;Unknown session &quot; + sessionId);</span>
<span class="nc" id="L433">                    return;</span>
                }

<span class="fc" id="L436">                session.handleHooksInvoke(hookType, input).thenAccept(output -&gt; {</span>
                    try {
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                        if (output != null) {</span>
<span class="fc" id="L439">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, output));</span>
                        } else {
<span class="nc" id="L441">                            rpc.sendResponse(Long.parseLong(requestId), Map.of(&quot;output&quot;, (Object) null));</span>
                        }
<span class="nc" id="L443">                    } catch (IOException e) {</span>
<span class="nc" id="L444">                        LOG.log(Level.SEVERE, &quot;Error sending hooks response&quot;, e);</span>
<span class="fc" id="L445">                    }</span>
<span class="fc" id="L446">                }).exceptionally(ex -&gt; {</span>
                    try {
<span class="fc" id="L448">                        rpc.sendErrorResponse(Long.parseLong(requestId), -32603,</span>
<span class="fc" id="L449">                                &quot;Hooks handler error: &quot; + ex.getMessage());</span>
<span class="nc" id="L450">                    } catch (IOException e) {</span>
<span class="nc" id="L451">                        LOG.log(Level.SEVERE, &quot;Error sending hooks error&quot;, e);</span>
<span class="fc" id="L452">                    }</span>
<span class="fc" id="L453">                    return null;</span>
                });
<span class="nc" id="L455">            } catch (Exception e) {</span>
<span class="nc" id="L456">                LOG.log(Level.SEVERE, &quot;Error handling hooks invoke&quot;, e);</span>
<span class="fc" id="L457">            }</span>
<span class="fc" id="L458">        });</span>
<span class="fc" id="L459">    }</span>

    private void verifyProtocolVersion(Connection connection) throws Exception {
<span class="fc" id="L462">        int expectedVersion = SdkProtocolVersion.get();</span>
<span class="fc" id="L463">        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc" id="L464">        params.put(&quot;message&quot;, null);</span>
<span class="fc" id="L465">        PingResponse pingResponse = connection.rpc.invoke(&quot;ping&quot;, params, PingResponse.class).get(30, TimeUnit.SECONDS);</span>

<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() == null) {</span>
<span class="nc" id="L468">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
                    + &quot;, but server does not report a protocol version. &quot;
                    + &quot;Please update your server to ensure compatibility.&quot;);
        }

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (pingResponse.getProtocolVersion() != expectedVersion) {</span>
<span class="nc" id="L474">            throw new RuntimeException(&quot;SDK protocol version mismatch: SDK expects version &quot; + expectedVersion</span>
<span class="nc" id="L475">                    + &quot;, but server reports version &quot; + pingResponse.getProtocolVersion() + &quot;. &quot;</span>
                    + &quot;Please update your SDK or server to ensure compatibility.&quot;);
        }
<span class="fc" id="L478">    }</span>

    /**
     * Stops the client and closes all sessions.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; stop() {
<span class="nc" id="L486">        List&lt;CompletableFuture&lt;Void&gt;&gt; closeFutures = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (CopilotSession session : new ArrayList&lt;&gt;(sessions.values())) {</span>
<span class="nc" id="L489">            closeFutures.add(CompletableFuture.runAsync(() -&gt; {</span>
                try {
<span class="nc" id="L491">                    session.close();</span>
<span class="nc" id="L492">                } catch (Exception e) {</span>
<span class="nc" id="L493">                    LOG.log(Level.WARNING, &quot;Error closing session &quot; + session.getSessionId(), e);</span>
<span class="nc" id="L494">                }</span>
<span class="nc" id="L495">            }));</span>
<span class="nc" id="L496">        }</span>
<span class="nc" id="L497">        sessions.clear();</span>

<span class="nc" id="L499">        return CompletableFuture.allOf(closeFutures.toArray(new CompletableFuture[0]))</span>
<span class="nc" id="L500">                .thenCompose(v -&gt; cleanupConnection());</span>
    }

    /**
     * Forces an immediate stop of the client without graceful cleanup.
     *
     * @return A future that completes when the client is stopped
     */
    public CompletableFuture&lt;Void&gt; forceStop() {
<span class="fc" id="L509">        sessions.clear();</span>
<span class="fc" id="L510">        return cleanupConnection();</span>
    }

    private CompletableFuture&lt;Void&gt; cleanupConnection() {
<span class="fc" id="L514">        CompletableFuture&lt;Connection&gt; future = connectionFuture;</span>
<span class="fc" id="L515">        connectionFuture = null;</span>

        // Clear models cache
<span class="fc" id="L518">        modelsCache = null;</span>

<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (future == null) {</span>
<span class="fc" id="L521">            return CompletableFuture.completedFuture(null);</span>
        }

<span class="fc" id="L524">        return future.thenAccept(connection -&gt; {</span>
            try {
<span class="fc" id="L526">                connection.rpc.close();</span>
<span class="nc" id="L527">            } catch (Exception e) {</span>
<span class="nc" id="L528">                LOG.log(Level.FINE, &quot;Error closing RPC&quot;, e);</span>
<span class="fc" id="L529">            }</span>

<span class="pc bpc" id="L531" title="1 of 2 branches missed.">            if (connection.process != null) {</span>
                try {
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                    if (connection.process.isAlive()) {</span>
<span class="fc" id="L534">                        connection.process.destroyForcibly();</span>
                    }
<span class="nc" id="L536">                } catch (Exception e) {</span>
<span class="nc" id="L537">                    LOG.log(Level.FINE, &quot;Error killing process&quot;, e);</span>
<span class="fc" id="L538">                }</span>
            }
<span class="pc" id="L540">        }).exceptionally(ex -&gt; null);</span>
    }

    /**
     * Creates a new Copilot session with the specified configuration.
     * &lt;p&gt;
     * The session maintains conversation state and can be used to send messages and
     * receive responses. Remember to close the session when done.
     *
     * @param config
     *            configuration for the session (model, tools, etc.)
     * @return a future that resolves with the created CopilotSession
     * @see #createSession()
     * @see SessionConfig
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession(SessionConfig config) {
<span class="fc" id="L556">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L557">            CreateSessionRequest request = new CreateSessionRequest();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L559">                request.setModel(config.getModel());</span>
<span class="fc" id="L560">                request.setSessionId(config.getSessionId());</span>
<span class="fc" id="L561">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">                request.setTools(config.getTools() != null</span>
<span class="fc" id="L563">                        ? config.getTools().stream()</span>
<span class="fc" id="L564">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="fc" id="L565">                                .collect(Collectors.toList())</span>
<span class="fc" id="L566">                        : null);</span>
<span class="fc" id="L567">                request.setSystemMessage(config.getSystemMessage());</span>
<span class="fc" id="L568">                request.setAvailableTools(config.getAvailableTools());</span>
<span class="fc" id="L569">                request.setExcludedTools(config.getExcludedTools());</span>
<span class="fc" id="L570">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                boolean requestUserInput = config.getOnUserInputRequest() != null;</span>
<span class="fc" id="L573">                LOG.fine(&quot;Setting requestUserInput: &quot; + requestUserInput + &quot; for session.create&quot;);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                request.setRequestUserInput(requestUserInput ? true : null);</span>
<span class="pc bpc" id="L575" title="1 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L576">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L578">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L579">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L580">                request.setInfiniteSessions(config.getInfiniteSessions());</span>
<span class="fc" id="L581">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L582">                request.setDisabledSkills(config.getDisabledSkills());</span>
<span class="fc" id="L583">                request.setConfigDir(config.getConfigDir());</span>
            }

<span class="fc" id="L586">            return connection.rpc.invoke(&quot;session.create&quot;, request, CreateSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L587">                CopilotSession session = new CopilotSession(response.getSessionId(), connection.rpc,</span>
<span class="fc" id="L588">                        response.getWorkspacePath());</span>
<span class="fc bfc" id="L589" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="fc" id="L590">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L592" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L593">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="fc bfc" id="L595" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="fc" id="L596">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="fc bfc" id="L598" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="fc" id="L599">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L601">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L602">                return session;</span>
            });
        });
    }

    /**
     * Creates a new Copilot session with default configuration.
     *
     * @return a future that resolves with the created CopilotSession
     * @see #createSession(SessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; createSession() {
<span class="fc" id="L614">        return createSession(null);</span>
    }

    /**
     * Resumes an existing Copilot session.
     * &lt;p&gt;
     * This restores a previously saved session, allowing you to continue a
     * conversation. The session's history is preserved.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @param config
     *            configuration for the resumed session
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String)
     * @see #listSessions()
     * @see #getLastSessionId()
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId, ResumeSessionConfig config) {
<span class="fc" id="L633">        return ensureConnected().thenCompose(connection -&gt; {</span>
<span class="fc" id="L634">            ResumeSessionRequest request = new ResumeSessionRequest();</span>
<span class="fc" id="L635">            request.setSessionId(sessionId);</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (config != null) {</span>
<span class="fc" id="L637">                request.setReasoningEffort(config.getReasoningEffort());</span>
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">                request.setTools(config.getTools() != null</span>
<span class="nc" id="L639">                        ? config.getTools().stream()</span>
<span class="nc" id="L640">                                .map(t -&gt; new ToolDef(t.getName(), t.getDescription(), t.getParameters()))</span>
<span class="nc" id="L641">                                .collect(Collectors.toList())</span>
<span class="fc" id="L642">                        : null);</span>
<span class="fc" id="L643">                request.setProvider(config.getProvider());</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                request.setRequestPermission(config.getOnPermissionRequest() != null ? true : null);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                request.setRequestUserInput(config.getOnUserInputRequest() != null ? true : null);</span>
<span class="pc bpc" id="L646" title="3 of 4 branches missed.">                request.setHooks(config.getHooks() != null &amp;&amp; config.getHooks().hasHooks() ? true : null);</span>
<span class="fc" id="L647">                request.setWorkingDirectory(config.getWorkingDirectory());</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                request.setDisableResume(config.isDisableResume() ? true : null);</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                request.setStreaming(config.isStreaming() ? true : null);</span>
<span class="fc" id="L650">                request.setMcpServers(config.getMcpServers());</span>
<span class="fc" id="L651">                request.setCustomAgents(config.getCustomAgents());</span>
<span class="fc" id="L652">                request.setSkillDirectories(config.getSkillDirectories());</span>
<span class="fc" id="L653">                request.setDisabledSkills(config.getDisabledSkills());</span>
            }

<span class="fc" id="L656">            return connection.rpc.invoke(&quot;session.resume&quot;, request, ResumeSessionResponse.class).thenApply(response -&gt; {</span>
<span class="fc" id="L657">                CopilotSession session = new CopilotSession(response.getSessionId(), connection.rpc,</span>
<span class="fc" id="L658">                        response.getWorkspacePath());</span>
<span class="pc bpc" id="L659" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getTools() != null) {</span>
<span class="nc" id="L660">                    session.registerTools(config.getTools());</span>
                }
<span class="fc bfc" id="L662" title="All 4 branches covered.">                if (config != null &amp;&amp; config.getOnPermissionRequest() != null) {</span>
<span class="fc" id="L663">                    session.registerPermissionHandler(config.getOnPermissionRequest());</span>
                }
<span class="pc bpc" id="L665" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getOnUserInputRequest() != null) {</span>
<span class="nc" id="L666">                    session.registerUserInputHandler(config.getOnUserInputRequest());</span>
                }
<span class="pc bpc" id="L668" title="1 of 4 branches missed.">                if (config != null &amp;&amp; config.getHooks() != null) {</span>
<span class="nc" id="L669">                    session.registerHooks(config.getHooks());</span>
                }
<span class="fc" id="L671">                sessions.put(response.getSessionId(), session);</span>
<span class="fc" id="L672">                return session;</span>
            });
        });
    }

    /**
     * Resumes an existing session with default configuration.
     *
     * @param sessionId
     *            the ID of the session to resume
     * @return a future that resolves with the resumed CopilotSession
     * @see #resumeSession(String, ResumeSessionConfig)
     */
    public CompletableFuture&lt;CopilotSession&gt; resumeSession(String sessionId) {
<span class="fc" id="L686">        return resumeSession(sessionId, null);</span>
    }

    /**
     * Gets the current connection state.
     *
     * @return the current connection state
     * @see ConnectionState
     */
    public ConnectionState getState() {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (connectionFuture == null)</span>
<span class="fc" id="L697">            return ConnectionState.DISCONNECTED;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (connectionFuture.isCompletedExceptionally())</span>
<span class="nc" id="L699">            return ConnectionState.ERROR;</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (!connectionFuture.isDone())</span>
<span class="nc" id="L701">            return ConnectionState.CONNECTING;</span>
<span class="nc" id="L702">        return ConnectionState.CONNECTED;</span>
    }

    /**
     * Pings the server to check connectivity.
     * &lt;p&gt;
     * This can be used to verify that the server is responsive and to check the
     * protocol version.
     *
     * @param message
     *            an optional message to echo back
     * @return a future that resolves with the ping response
     * @see PingResponse
     */
    public CompletableFuture&lt;PingResponse&gt; ping(String message) {
<span class="nc" id="L717">        return ensureConnected().thenCompose(connection -&gt; connection.rpc.invoke(&quot;ping&quot;,</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                Map.of(&quot;message&quot;, message != null ? message : &quot;&quot;), PingResponse.class));</span>
    }

    /**
     * Gets CLI status including version and protocol information.
     *
     * @return a future that resolves with the status response containing version
     *         and protocol version
     * @see GetStatusResponse
     */
    public CompletableFuture&lt;GetStatusResponse&gt; getStatus() {
<span class="nc" id="L729">        return ensureConnected()</span>
<span class="nc" id="L730">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;status.get&quot;, Map.of(), GetStatusResponse.class));</span>
    }

    /**
     * Gets current authentication status.
     *
     * @return a future that resolves with the authentication status
     * @see GetAuthStatusResponse
     */
    public CompletableFuture&lt;GetAuthStatusResponse&gt; getAuthStatus() {
<span class="nc" id="L740">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L741">                connection -&gt; connection.rpc.invoke(&quot;auth.getStatus&quot;, Map.of(), GetAuthStatusResponse.class));</span>
    }

    /**
     * Lists available models with their metadata.
     * &lt;p&gt;
     * Results are cached after the first successful call to avoid rate limiting.
     * The cache is cleared when the client disconnects.
     *
     * @return a future that resolves with a list of available models
     * @see ModelInfo
     */
    public CompletableFuture&lt;List&lt;ModelInfo&gt;&gt; listModels() {
        // Check cache first
<span class="nc" id="L755">        List&lt;ModelInfo&gt; cached = modelsCache;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (cached != null) {</span>
<span class="nc" id="L757">            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(cached));</span>
        }

<span class="nc" id="L760">        return ensureConnected().thenCompose(connection -&gt; {</span>
            // Double-check cache inside lock
<span class="nc" id="L762">            synchronized (modelsCacheLock) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                if (modelsCache != null) {</span>
<span class="nc" id="L764">                    return CompletableFuture.completedFuture(new ArrayList&lt;&gt;(modelsCache));</span>
                }
<span class="nc" id="L766">            }</span>

<span class="nc" id="L768">            return connection.rpc.invoke(&quot;models.list&quot;, Map.of(), GetModelsResponse.class).thenApply(response -&gt; {</span>
<span class="nc" id="L769">                List&lt;ModelInfo&gt; models = response.getModels();</span>
<span class="nc" id="L770">                synchronized (modelsCacheLock) {</span>
<span class="nc" id="L771">                    modelsCache = models;</span>
<span class="nc" id="L772">                }</span>
<span class="nc" id="L773">                return new ArrayList&lt;&gt;(models); // Return a copy to prevent cache mutation</span>
            });
        });
    }

    /**
     * Gets the ID of the most recently used session.
     * &lt;p&gt;
     * This is useful for resuming the last conversation without needing to list all
     * sessions.
     *
     * @return a future that resolves with the last session ID, or {@code null} if
     *         no sessions exist
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;String&gt; getLastSessionId() {
<span class="nc" id="L789">        return ensureConnected().thenCompose(</span>
<span class="nc" id="L790">                connection -&gt; connection.rpc.invoke(&quot;session.getLastId&quot;, Map.of(), GetLastSessionIdResponse.class)</span>
<span class="nc" id="L791">                        .thenApply(GetLastSessionIdResponse::getSessionId));</span>
    }

    /**
     * Deletes a session by ID.
     * &lt;p&gt;
     * This permanently removes the session and its conversation history.
     *
     * @param sessionId
     *            the ID of the session to delete
     * @return a future that completes when the session is deleted
     * @throws RuntimeException
     *             if the deletion fails
     */
    public CompletableFuture&lt;Void&gt; deleteSession(String sessionId) {
<span class="fc" id="L806">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="fc" id="L807">                .invoke(&quot;session.delete&quot;, Map.of(&quot;sessionId&quot;, sessionId), DeleteSessionResponse.class)</span>
<span class="fc" id="L808">                .thenAccept(response -&gt; {</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">                    if (!response.isSuccess()) {</span>
<span class="nc" id="L810">                        throw new RuntimeException(</span>
<span class="nc" id="L811">                                &quot;Failed to delete session &quot; + sessionId + &quot;: &quot; + response.getError());</span>
                    }
<span class="fc" id="L813">                    sessions.remove(sessionId);</span>
<span class="fc" id="L814">                }));</span>
    }

    /**
     * Lists all available sessions.
     * &lt;p&gt;
     * Returns metadata about all sessions that can be resumed, including their IDs,
     * start times, and summaries.
     *
     * @return a future that resolves with a list of session metadata
     * @see SessionMetadata
     * @see #resumeSession(String)
     */
    public CompletableFuture&lt;List&lt;SessionMetadata&gt;&gt; listSessions() {
<span class="fc" id="L828">        return ensureConnected()</span>
<span class="fc" id="L829">                .thenCompose(connection -&gt; connection.rpc.invoke(&quot;session.list&quot;, Map.of(), ListSessionsResponse.class)</span>
<span class="fc" id="L830">                        .thenApply(ListSessionsResponse::getSessions));</span>
    }

    /**
     * Gets the ID of the session currently displayed in the TUI.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @return a future that resolves with the session ID, or null if no foreground
     *         session is set
     */
    public CompletableFuture&lt;String&gt; getForegroundSessionId() {
<span class="nc" id="L843">        return ensureConnected().thenCompose(connection -&gt; connection.rpc</span>
<span class="nc" id="L844">                .invoke(&quot;session.getForeground&quot;, Map.of(),</span>
                        com.github.copilot.sdk.json.GetForegroundSessionResponse.class)
<span class="nc" id="L846">                .thenApply(com.github.copilot.sdk.json.GetForegroundSessionResponse::getSessionId));</span>
    }

    /**
     * Requests the TUI to switch to displaying the specified session.
     * &lt;p&gt;
     * This is only available when connecting to a server running in TUI+server mode
     * (--ui-server).
     *
     * @param sessionId
     *            the ID of the session to display in the TUI
     * @return a future that completes when the operation is done
     * @throws RuntimeException
     *             if the operation fails
     */
    public CompletableFuture&lt;Void&gt; setForegroundSessionId(String sessionId) {
<span class="nc" id="L862">        return ensureConnected()</span>
<span class="nc" id="L863">                .thenCompose(</span>
<span class="nc" id="L864">                        connection -&gt; connection.rpc</span>
<span class="nc" id="L865">                                .invoke(&quot;session.setForeground&quot;, Map.of(&quot;sessionId&quot;, sessionId),</span>
                                        com.github.copilot.sdk.json.SetForegroundSessionResponse.class)
<span class="nc" id="L867">                                .thenAccept(response -&gt; {</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                                    if (!response.isSuccess()) {</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">                                        throw new RuntimeException(response.getError() != null</span>
<span class="nc" id="L870">                                                ? response.getError()</span>
<span class="nc" id="L871">                                                : &quot;Failed to set foreground session&quot;);</span>
                                    }
<span class="nc" id="L873">                                }));</span>
    }

    /**
     * Subscribes to all session lifecycle events.
     * &lt;p&gt;
     * Lifecycle events are emitted when sessions are created, deleted, updated, or
     * change foreground/background state (in TUI+server mode).
     *
     * @param handler
     *            a callback that receives lifecycle events
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L887">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L888">            lifecycleHandlers.add(handler);</span>
<span class="nc" id="L889">        }</span>
<span class="nc" id="L890">        return () -&gt; {</span>
<span class="nc" id="L891">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L892">                lifecycleHandlers.remove(handler);</span>
<span class="nc" id="L893">            }</span>
<span class="nc" id="L894">        };</span>
    }

    /**
     * Subscribes to a specific session lifecycle event type.
     *
     * @param eventType
     *            the event type to listen for (use
     *            {@link com.github.copilot.sdk.json.SessionLifecycleEventTypes}
     *            constants)
     * @param handler
     *            a callback that receives events of the specified type
     * @return an AutoCloseable that, when closed, unsubscribes the handler
     */
    public AutoCloseable onLifecycle(String eventType, com.github.copilot.sdk.json.SessionLifecycleHandler handler) {
<span class="nc" id="L909">        synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L910">            typedLifecycleHandlers.computeIfAbsent(eventType, k -&gt; new ArrayList&lt;&gt;()).add(handler);</span>
<span class="nc" id="L911">        }</span>
<span class="nc" id="L912">        return () -&gt; {</span>
<span class="nc" id="L913">            synchronized (lifecycleHandlersLock) {</span>
<span class="nc" id="L914">                List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="nc" id="L915">                        .get(eventType);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (handlers != null) {</span>
<span class="nc" id="L917">                    handlers.remove(handler);</span>
                }
<span class="nc" id="L919">            }</span>
<span class="nc" id="L920">        };</span>
    }

    void dispatchLifecycleEvent(com.github.copilot.sdk.json.SessionLifecycleEvent event) {
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; typed;
        List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; wildcard;

<span class="fc" id="L927">        synchronized (lifecycleHandlersLock) {</span>
<span class="fc" id="L928">            List&lt;com.github.copilot.sdk.json.SessionLifecycleHandler&gt; handlers = typedLifecycleHandlers</span>
<span class="fc" id="L929">                    .get(event.getType());</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">            typed = handlers != null ? new ArrayList&lt;&gt;(handlers) : new ArrayList&lt;&gt;();</span>
<span class="fc" id="L931">            wildcard = new ArrayList&lt;&gt;(lifecycleHandlers);</span>
<span class="fc" id="L932">        }</span>

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : typed) {</span>
            try {
<span class="nc" id="L936">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L937">            } catch (Exception e) {</span>
<span class="nc" id="L938">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L939">            }</span>
<span class="nc" id="L940">        }</span>

<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        for (com.github.copilot.sdk.json.SessionLifecycleHandler handler : wildcard) {</span>
            try {
<span class="nc" id="L944">                handler.onLifecycleEvent(event);</span>
<span class="nc" id="L945">            } catch (Exception e) {</span>
<span class="nc" id="L946">                LOG.log(Level.WARNING, &quot;Lifecycle handler error&quot;, e);</span>
<span class="nc" id="L947">            }</span>
<span class="nc" id="L948">        }</span>
<span class="fc" id="L949">    }</span>

    private CompletableFuture&lt;Connection&gt; ensureConnected() {
<span class="pc bpc" id="L952" title="1 of 4 branches missed.">        if (connectionFuture == null &amp;&amp; !options.isAutoStart()) {</span>
<span class="nc" id="L953">            throw new IllegalStateException(&quot;Client not connected. Call start() first.&quot;);</span>
        }

<span class="fc" id="L956">        start();</span>
<span class="fc" id="L957">        return connectionFuture;</span>
    }

    private ProcessInfo startCliServer() throws IOException, InterruptedException {
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">        String cliPath = options.getCliPath() != null ? options.getCliPath() : &quot;copilot&quot;;</span>
<span class="fc" id="L962">        List&lt;String&gt; args = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L964" title="1 of 2 branches missed.">        if (options.getCliArgs() != null) {</span>
<span class="nc" id="L965">            args.addAll(Arrays.asList(options.getCliArgs()));</span>
        }

<span class="fc" id="L968">        args.add(&quot;--server&quot;);</span>
<span class="fc" id="L969">        args.add(&quot;--log-level&quot;);</span>
<span class="fc" id="L970">        args.add(options.getLogLevel());</span>

<span class="pc bpc" id="L972" title="1 of 2 branches missed.">        if (options.isUseStdio()) {</span>
<span class="fc" id="L973">            args.add(&quot;--stdio&quot;);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">        } else if (options.getPort() &gt; 0) {</span>
<span class="nc" id="L975">            args.add(&quot;--port&quot;);</span>
<span class="nc" id="L976">            args.add(String.valueOf(options.getPort()));</span>
        }

        // Add auth-related flags
<span class="pc bpc" id="L980" title="2 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L981">            args.add(&quot;--auth-token-env&quot;);</span>
<span class="fc" id="L982">            args.add(&quot;COPILOT_SDK_AUTH_TOKEN&quot;);</span>
        }

        // Default UseLoggedInUser to false when GithubToken is provided
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">        boolean useLoggedInUser = options.getUseLoggedInUser() != null</span>
<span class="nc" id="L987">                ? options.getUseLoggedInUser()</span>
<span class="pc bpc" id="L988" title="2 of 4 branches missed.">                : (options.getGithubToken() == null || options.getGithubToken().isEmpty());</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">        if (!useLoggedInUser) {</span>
<span class="fc" id="L990">            args.add(&quot;--no-auto-login&quot;);</span>
        }

<span class="fc" id="L993">        List&lt;String&gt; command = resolveCliCommand(cliPath, args);</span>

<span class="fc" id="L995">        ProcessBuilder pb = new ProcessBuilder(command);</span>
<span class="fc" id="L996">        pb.redirectErrorStream(false);</span>

<span class="pc bpc" id="L998" title="1 of 2 branches missed.">        if (options.getCwd() != null) {</span>
<span class="fc" id="L999">            pb.directory(new File(options.getCwd()));</span>
        }

<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">        if (options.getEnvironment() != null) {</span>
<span class="fc" id="L1003">            pb.environment().clear();</span>
<span class="fc" id="L1004">            pb.environment().putAll(options.getEnvironment());</span>
        }
<span class="fc" id="L1006">        pb.environment().remove(&quot;NODE_DEBUG&quot;);</span>

        // Set auth token in environment if provided
<span class="pc bpc" id="L1009" title="2 of 4 branches missed.">        if (options.getGithubToken() != null &amp;&amp; !options.getGithubToken().isEmpty()) {</span>
<span class="fc" id="L1010">            pb.environment().put(&quot;COPILOT_SDK_AUTH_TOKEN&quot;, options.getGithubToken());</span>
        }

<span class="fc" id="L1013">        Process process = pb.start();</span>

        // Forward stderr to logger in background
<span class="fc" id="L1016">        Thread stderrThread = new Thread(() -&gt; {</span>
<span class="fc" id="L1017">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {</span>
                String line;
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">                while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L1020">                    LOG.fine(&quot;[CLI] &quot; + line);</span>
                }
<span class="nc" id="L1022">            } catch (IOException e) {</span>
<span class="nc" id="L1023">                LOG.log(Level.FINE, &quot;Error reading stderr&quot;, e);</span>
<span class="fc" id="L1024">            }</span>
<span class="fc" id="L1025">        }, &quot;cli-stderr-reader&quot;);</span>
<span class="fc" id="L1026">        stderrThread.setDaemon(true);</span>
<span class="fc" id="L1027">        stderrThread.start();</span>

<span class="fc" id="L1029">        Integer detectedPort = null;</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">        if (!options.isUseStdio()) {</span>
            // Wait for port announcement
<span class="nc" id="L1032">            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span>
<span class="nc" id="L1033">            Pattern portPattern = Pattern.compile(&quot;listening on port (\\d+)&quot;, Pattern.CASE_INSENSITIVE);</span>
<span class="nc" id="L1034">            long deadline = System.currentTimeMillis() + 30000;</span>

<span class="nc bnc" id="L1036" title="All 2 branches missed.">            while (System.currentTimeMillis() &lt; deadline) {</span>
<span class="nc" id="L1037">                String line = reader.readLine();</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                if (line == null) {</span>
<span class="nc" id="L1039">                    throw new IOException(&quot;CLI process exited unexpectedly&quot;);</span>
                }

<span class="nc" id="L1042">                Matcher matcher = portPattern.matcher(line);</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                if (matcher.find()) {</span>
<span class="nc" id="L1044">                    detectedPort = Integer.parseInt(matcher.group(1));</span>
<span class="nc" id="L1045">                    break;</span>
                }
<span class="nc" id="L1047">            }</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">            if (detectedPort == null) {</span>
<span class="nc" id="L1050">                process.destroyForcibly();</span>
<span class="nc" id="L1051">                throw new IOException(&quot;Timeout waiting for CLI to announce port&quot;);</span>
            }
        }

<span class="fc" id="L1055">        return new ProcessInfo(process, detectedPort);</span>
    }

    private List&lt;String&gt; resolveCliCommand(String cliPath, List&lt;String&gt; args) {
<span class="fc" id="L1059">        boolean isJsFile = cliPath.toLowerCase().endsWith(&quot;.js&quot;);</span>

<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (isJsFile) {</span>
<span class="nc" id="L1062">            List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1063">            result.add(&quot;node&quot;);</span>
<span class="nc" id="L1064">            result.add(cliPath);</span>
<span class="nc" id="L1065">            result.addAll(args);</span>
<span class="nc" id="L1066">            return result;</span>
        }

        // On Windows, use cmd /c to resolve the executable
<span class="fc" id="L1070">        String os = System.getProperty(&quot;os.name&quot;).toLowerCase();</span>
<span class="pc bpc" id="L1071" title="3 of 4 branches missed.">        if (os.contains(&quot;win&quot;) &amp;&amp; !new File(cliPath).isAbsolute()) {</span>
<span class="nc" id="L1072">            List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1073">            result.add(&quot;cmd&quot;);</span>
<span class="nc" id="L1074">            result.add(&quot;/c&quot;);</span>
<span class="nc" id="L1075">            result.add(cliPath);</span>
<span class="nc" id="L1076">            result.addAll(args);</span>
<span class="nc" id="L1077">            return result;</span>
        }

<span class="fc" id="L1080">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1081">        result.add(cliPath);</span>
<span class="fc" id="L1082">        result.addAll(args);</span>
<span class="fc" id="L1083">        return result;</span>
    }

    private Connection connectToServer(Process process, String tcpHost, Integer tcpPort) throws IOException {
        JsonRpcClient rpc;

<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">        if (options.isUseStdio()) {</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">            if (process == null) {</span>
<span class="nc" id="L1091">                throw new IllegalStateException(&quot;CLI process not started&quot;);</span>
            }
<span class="fc" id="L1093">            rpc = JsonRpcClient.fromProcess(process);</span>
        } else {
<span class="nc bnc" id="L1095" title="All 4 branches missed.">            if (tcpHost == null || tcpPort == null) {</span>
<span class="nc" id="L1096">                throw new IllegalStateException(&quot;Cannot connect because TCP host or port are not available&quot;);</span>
            }
<span class="nc" id="L1098">            Socket socket = new Socket(tcpHost, tcpPort);</span>
<span class="nc" id="L1099">            rpc = JsonRpcClient.fromSocket(socket);</span>
        }

<span class="fc" id="L1102">        return new Connection(rpc, process);</span>
    }

    @Override
    public void close() {
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">        if (disposed)</span>
<span class="nc" id="L1108">            return;</span>
<span class="fc" id="L1109">        disposed = true;</span>
        try {
<span class="fc" id="L1111">            forceStop().get(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L1112">        } catch (Exception e) {</span>
<span class="nc" id="L1113">            LOG.log(Level.FINE, &quot;Error during close&quot;, e);</span>
<span class="fc" id="L1114">        }</span>
<span class="fc" id="L1115">    }</span>

<span class="fc" id="L1117">    private static record ProcessInfo(Process process, Integer port) {</span>
    };

<span class="fc" id="L1120">    private static record Connection(JsonRpcClient rpc, Process process) {</span>
    };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>